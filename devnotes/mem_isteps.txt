## Power off DRAM - VDDR and vPP (13.1)

Must drop VDDR first, then VPP. Only done when powered on, i.e. warm reboot.
Done using GPIO (TODO: addresses?)

## Mem PLL reset (13.2)

> - This step is a no-op on cumulus as the centaur is already has its PLLs setup
>   in step 11
> - This step is a no-op if memory is running in synchronous mode since the MCAs
>   are using the nest PLL, HWP detect and exits
> - If in async mode then this HWP will put the PLL into bypass, reset mode
> - Disable listen_to_sync for MEM chiplet, whenever MEM is not in sync to NEST

For each functional Proc:
> if ( !ATTR_MC_SYNC_MODE && !ATTR_CHIP_EC_FEATURE_DMI_MC_PLL_SCAN_BUCKETS )
  For each functional MC(BIST?):
    - Assert endpoint reset
      PERV_NET_CTRL0_WOR = 0x8..0 >> PERV_1_NET_CTRL0_PCB_EP_RESET    // 0x8..0

    - Mask PLL unlock error in PCB slave
      PERV_SLAVE_CONFIG_REG |= 0x8..0 >> 12 (no name?)                // 0x0008..0

    - Move MC PLL into reset state
      PERV_NET_CTRL0_WOR = 0x8..0 >> PERV_1_NET_CTRL0_PLL_BYPASS      // 0x04..0
      PERV_NET_CTRL0_WOR = 0x8..0 >> PERV_1_NET_CTRL0_PLL_RESET       // 0x08..0
      PERV_NET_CTRL0_WOR = 0x8..0 >> PERV_1_NET_CTRL0_PLL_TEST_EN     // 0x10..0

    - Assert MEM PLDY and DCC bypass
      PERV_NET_CTRL1_WOR =
              (0x8..0 >> PERV_1_NET_CTRL1_CLK_DCC_BYPASS_EN) |             // 0x4..0
              (0x8..0 >> PERV_1_NET_CTRL1_CLK_PDLY_BYPASS_EN               // 0x2..0

    - Drop endpoint reset
      PERV_NET_CTRL0_WAND = ~(0x8..0 >> PERV_1_NET_CTRL0_PCB_EP_RESET)     // ~0x4..0

    - Disable listen to sync pulse to MC chiplet, when MEM is not in sync to nest
      PERV_SYNC_CONFIG |= 0x8..0 >> PERV_1_SYNC_CONFIG_LISTEN_TO_PULSE_DIS // 0x08..0

    - Initialize OPCG_ALIGN register
      PERV_OPCG_ALIGN =
                (OPCG_ALIGN_INOP_ALIGN  &   0xf) << 60 |    // 0x5   << 60   (8:1)
                (OPCG_ALIGN_INOP_WAIT   &  0xff) << 44 |    // 0x00  << 44
                (OPCG_ALIGN_WAIT_CYCLES & 0xfff) <<  0 |    // 0x020 <<  0
                (OPCG_ALIGN_SCAN_RATIO  &  0x1f) << 12      // 0x00  << 12   (1:1)

    - scan0 flush PLL boundary ring
      PERV_CLK_REGION =
                (0x8..0 >> PERV_1_SCAN_REGION_TYPE_UNIT10)  |    // 0x8..0 >> 14
                (0x8..0 >> PERV_1_CLK_REGION_SEL_THOLD_SL)  |    // 0x8..0 >> 48
                (0x8..0 >> PERV_1_CLK_REGION_SEL_THOLD_NSL) |    // 0x8..0 >> 49
                (0x8..0 >> PERV_1_CLK_REGION_SEL_THOLD_ARY)      // 0x8..0 >> 50
      PERV_SCAN_REGION_TYPE = 
                (0x8..0 >> PERV_1_SCAN_REGION_TYPE_UNIT10) |     // 0x8..0 >> 14
                (0x8..0 >> PERV_1_SCAN_REGION_TYPE_BNDY)         // 0x8..0 >> 56
      PERV_OPCG_REG0 &= ~(0x8..0 >> PERV_1_OPCG_REG0_RUNN_MODE)  // 0x8..0 >> 0
      PERV_OPCG_REG0 |= 0x8..0 >> PERV_1_OPCG_REG0_RUN_SCAN0     // 0x8..0 >> 2
      timeout(200 * 16us):
        if (PERV_CPLT_STAT0 & (0x8..0 >> PERV_1_CPLT_STAT0_CC_CTRL_OPCG_DONE_DC) == 1) break   // 0x8..0 >> 8
        delay(16us)
      PERV_CLK_REGION = 0
      PERV_SCAN_REGION_TYPE = 0

## Mem PLL initf : PLL Initfile for MBAs (13.3)

> - This step is a no-op on cumulus
> - This step is a no-op if memory is running in synchronous mode since the
>   MCAs are using the nest PLL, HWP detect and exits
> - MCA PLL setup
>   - Note that Hostboot doesn't support twiddling bits, Looks up which "bucket"
>     (ring) to use from attributes set during mss_freq
>   - Then request the SBE to scan ringId with setPulse
>     - SBE needs to support 5 RS4 images
>     - Data is stored as a ring image in the SBE that is frequency specific
>     - 5 different frequencies (1866, 2133, 2400, 2667, EXP)

For each functional Proc:
> if (ATTR_MC_SYNC_MODE == 0 && ATTR_CHIP_EC_FEATURE_DMI_MC_PLL_SCAN_BUCKETS == 0)
  For each functional MCBIST
    - fapi2::putRing(mbist, ring_id(depends on RAM freq), RING_MODE_SET_PULSE_NSL)
      - /src/usr/fapi2/plat_hw_access.C:943

## mem_pll_setup: Setup PLL for MBAs (13.4)

> - This step is a no-op on cumulus
> - This step is a no-op if memory is running in synchronous mode since the MCAs
>   are using the nest PLL, HWP detect and exits
> - MCA PLL setup
>   - Moved PLL out of bypass(just DDR)
> - Performs PLL checking

For each functional Proc:
> if ( !ATTR_MC_SYNC_MODE && !ATTR_CHIP_EC_FEATURE_DMI_MC_PLL_SCAN_BUCKETS )
  For each functional MC(BIST?):
    - Drop PLDY bypass of Progdelay logic
      PERV_NET_CTRL1_WAND = ~(0x8..0 >> PERV_1_NET_CTRL1_CLK_PDLY_BYPASS_EN)   // 0x8..0 >> 2

    - Drop DCC bypass of DCC logic
      PERV_NET_CTRL1_WAND = ~(0x8..0 >> PERV_1_NET_CTRL1_CLK_DCC_BYPASS_EN)    // 0x8..0 >> 1

    > if (ATTR_NEST_MEM_X_O_PCI_BYPASS == 0)
    > {
      - Drop PLL test enable
        PERV_NET_CTRL0_WAND = ~(0x8..0 >> PERV_1_NET_CTRL0_PLL_TEST_EN)        // 0x8..0 >> 3

      - Drop PLL reset
        PERV_NET_CTRL0_WAND = ~(0x8..0 >> PERV_1_NET_CTRL0_PLL_RESET)          // 0x8..0 >> 4

      delay(5ms)

      - check PLL lock
        assert(PERV_PLL_LOCK_REG & 0x8..0 == 1)

      - Drop PLL Bypass
        PERV_NET_CTRL0_WAND = ~(0x8..0 >> PERV_1_NET_CTRL0_PLL_BYPASS)         // 0x8..0 >> 5

      - Set scan ratio to 4:1
        PERV_OPCG_ALIGN = (PERV_OPCG_ALIGN & ~(0x1f << 47)) | OPCG_ALIGN_SCAN_RATIO << 47	// | 0x3 << 47

    > }

    - Reset PCB Slave error register
      PERV_ERROR_REG = ~0

    - Unmask PLL unlock error in PCB slave
      PERV_SLAVE_CONFIG_REG &= ~(0x8..0 >> 12)        // 0x0008..0

## proc_mcs_skewadjust: Update clock mesh deskew (13.5)

> This step is a no-op

## mem_startclocks: Start clocks on MBA/MCAs (13.6)

> - This step is a no-op on cumulus
> - This step is a no-op if memory is running in synchronous mode since the MCAs
>   are using the nest PLL, HWP detect and exits
> - Drop fences and tholds on MBA/MCAs to start the functional clocks

For each functional Proc:
pg_vector = bitmap of ATTR_CHIP_UNIT_POS of functional Perv children of Proc
 - /src/import/chips/p9/procedures/hwp/perv/p9_sbe_common.C:692
> if(!ATTR_MC_SYNC_MODE)
> {
  For each functional MC(BIST?):
    - Call p9_mem_startclocks_cplt_ctrl_action_function for Mc chiplets
      p9_mem_startclocks_cplt_ctrl_action_function:
        u16 cplt_ctrl_init = ~(MC.ATTR_PG >> (16-4-11)) & 0x7ff         // >> 1
        - Drop partial good fences
          PERV_CPLT_CTRL1_CLEAR = (~MC.ATTR_PG & (0x8..0 >> 3)) | (cplt_ctrl_init << 1)
        - reset abistclk_muxsel and syncclk_muxsel
          PERV_CPLT_CTRL0_CLEAR =
              (0x8..0 >> PEC_CPLT_CTRL0_CTRL_CC_ABSTCLK_MUXSEL_DC) |                   // 0x8..0
              (0x8..0 >> PEC_CPLT_CTRL0_TC_UNIT_SYNCCLK_MUXSEL_DC)                     // 0x4..0

    - Call module align chiplets for Mc chiplets
      p9_sbe_common_align_chiplets:
        - For all chiplets: exit flush
          PERV_CPLT_CTRL0_OR = 0x8..0 >> PERV_1_CPLT_CTRL0_CTRL_CC_FLUSHMODE_INH_DC    // 0x2..0
        - For all chiplets: enable alignement
          PERV_CPLT_CTRL0_OR = 0x8..0 >> PERV_1_CPLT_CTRL0_CTRL_CC_FORCE_ALIGN_DC      // 0x1..0
        - Clear chiplet is aligned
          PERV_SYNC_CONFIG |= 0x8..0 >> PERV_1_SYNC_CONFIG_CLEAR_CHIPLET_IS_ALIGNED    // 0x01..0
        - Unset Clear chiplet is aligned
          PERV_SYNC_CONFIG &= ~(0x8..0 >> PERV_1_SYNC_CONFIG_CLEAR_CHIPLET_IS_ALIGNED) // 0x01..0
        delay(100us)
        - Poll OPCG done bit to check for run-N completeness
          timeout(10*100us):
            if (PERV_CPLT_STAT0 & (0x8..0 >> PERV_1_CPLT_STAT0_CC_CTRL_CHIPLET_IS_ALIGNED_DC) == 1) break    // 0x8..0 >> 9
            delay(100us)
        - For all chiplets: disable alignement
          PERV_CPLT_CTRL0_CLEAR = 0x8..0 >> PERV_1_CPLT_CTRL0_CTRL_CC_FORCE_ALIGN_DC   // 0x1..0

      l_clock_regions = (0x7fe & (~MD.ATTR_PG >> 1))        // uint16 to uint64 buffer conversion

    - Call module clock start stop for MC01, MC23
      p9_sbe_common_clock_start_stop(l_trgt_chplt, CLOCK_CMD = 1,
                                                      DONT_STARTSLAVE = 0, DONT_STARTMASTER = 0, l_clock_regions,
                                                      CLOCK_TYPES = 0x7):
        - Chiplet exit flush
          PERV_CPLT_CTRL0_OR = 0x8..0 >> PERV_1_CPLT_CTRL0_CTRL_CC_FLUSHMODE_INH_DC   // 0x2..0
        - Clear Scan region type register
          PERV_SCAN_REGION_TYPE = 0
        - Reading the initial status of clock controller
          l_sl_clock_status = PERV_CLOCK_STAT_SL
          l_nsl_clock_status = PERV_CLOCK_STAT_NSL
          l_ary_clock_status = PERV_CLOCK_STAT_ARY
            // Debug information only?
        - Setup all Clock Domains and Clock Types
          PERV_CLK_REGION = (PERV_CLK_REGION & ~(0xfffe00000000e000)) |
              (CLOCK_CMD << 62)                         |
              (0x8..0 >> PERV_1_CLK_REGION_SLAVE_MODE)  |         // >> 2
              (0x8..0 >> PERV_1_CLK_REGION_MASTER_MODE) |         // >> 3
              (l_clock_regions << (64-4-11))            |         // << 49
              ((CLOCK_TYPES & 0x7) << (64-48-3))                  // << 13
        - Poll OPCG done bit to check for completeness
          timeout(10*100us):
            if (PERV_CPLT_STAT0 & (0x8..0 >> PERV_1_CPLT_STAT0_CC_CTRL_OPCG_DONE_DC) == 1) break    // 0x8..0 >> 8
            delay(100us)
        > if (!DONT_STARTSLAVE && !DONT_STARTMASTER)          // true
        > {
          p9_sbe_common_check_status(i_regions, l_{sl,nsl,ary}_clock_status, l_reg_{sl,nsl,ary},
                                            i_clock_cmd, l_exp_{sl,nsl,ary}_clock_status)
          assert(PERV_CLOCK_STAT_{SL,NSL,ARY} == l_exp_{sl,nsl,ary}_clock_status)
          + debug output
        > }

    - Call p9_mem_startclocks_fence_setup_function for Mc chiplets
      p9_mem_startclocks_fence_setup_function(l_trgt_chplt, pg_vector):
        > if ((MC.ATTR_CHIP_UNIT_POS == 0x07 && pg_vector & 0x8..0 >> 5) ||
        >     (MC.ATTR_CHIP_UNIT_POS == 0x08 && pg_vector & 0x8..0 >> 3))
        > {
          - Drop chiplet fence
            PERV_NET_CTRL0_WAND = ~(0x8..0 >> PERV_1_NET_CTRL0_FENCE_EN)    // >> 18
        > }

    - Call p9_mem_startclocks_flushmode for Mc chiplets
      p9_mem_startclocks_flushmode:
        - Clear flush_inhibit to go in to flush mode
          PERV_CPLT_CTRL0_CLEAR = 0x8..0 >> PEC_CPLT_CTRL0_CTRL_CC_FLUSHMODE_INH_DC     // >> 2

    - Call p9_sbe_common_configure_chiplet_FIR for MC chiplets
      p9_sbe_common_configure_chiplet_FIR:
        - reset pervasive FIR
          PERV_LOCAL_FIR = 0
        - configure pervasive FIR action/mask
          PERV_LOCAL_FIR_ACTION0 = PERV_LFIR_ACTION0[ATTR_CHIP_UNIT_POS-1]
          PERV_LOCAL_FIR_ACTION1 = PERV_LFIR_ACTION1[ATTR_CHIP_UNIT_POS-1]
        > #ifdef __PPE__ and test for FSP-less system, no-op with SP (?)
          PERV_LOCAL_FIR_MASK = PERV_LFIR_MASK[ATTR_CHIP_UNIT_POS-1]
        - reset XFIR
          PERV_XFIR = 0
        - configure XFIR mask
          PERV_FIR_MASK = PERV_XFIR_MASK[ATTR_CHIP_UNIT_POS-1]

    - Reset FBC chiplet configuration
      PERV_CPLT_CONF0 = (PERV_CPLT_CONF0 & ~(0xfef8ULL))  |
              ATTR_PROC_FABRIC_SYSTEM_ID << (64-56-5)     |   // << 3
              ATTR_PROC_FABRIC_GROUP_ID  << (64-48-4)     |   // << 12
              ATTR_PROC_FABRIC_CHIP_ID   << (64-52-3)         // << 9

    - Add to Multicast Group
      // avoid setting if register is already set, i.e. != p9SbeChipletReset::MCGR_CNFG_SETTING_EMPTY
      PERV_MULTICAST_GROUP_1 = p9SbeChipletReset::MCGR_CNFG_SETTING_GROUP0 // Why GROUP_1 = GROUP0?
      PERV_MULTICAST_GROUP_2 = p9SbeChipletReset::MCGR_CNFG_SETTING_GROUP2
> }

End for each Proc:
- SCOM::enableMemChipletMulticast()

## host_enable_memvolt: Enable the VDDR3 Voltage Rail (13.7)

> - BMC based systems â€“ this is a no-op

## mss_scominit: Perform scom inits to MC and PHY (13.8)

> - HW units included are MCBIST, MCA/PHY (Nimbus) or membuf, L4, MBAs (Cumulus)
> - Does not use initfiles, coded into HWP
> - Uses attributes from previous step
> - Pushes memory extent configuration into the MBA/MCAs
>   - Addresses are pulled from attributes, set previously by mss_eff_config
>   - MBA/MCAs always start at address 0, address map controlled by
>     proc_setup_bars below

for each functional MCBIST:
  assert(count_dimms(MCBIST) > 0)
  for each functional or magic MCA:
    > if (count_dimms(MCA) > 0)
    > {   // no DIMM = no SPD = no parameters to init MCA
      - mca scominit
        p9n_mca_scom(MCA, MCBIST, MCA.getParent<MCS>, FAPI_SYSTEM, MCBIST.getParent<PROC_CHIP>)     // generated from initfile
          l_chip_ec = PROC_CHIP.ATTR_EC
          l_chip_id = PROC_CHIP.ATTR_NAME
          l_TGT2_ATTR_EFF_NUM_RANKS_PER_DIMM = MCS.ATTR_EFF_NUM_RANKS_PER_DIMM
          l_def_POSITION = l_TGT0_ATTR_CHIP_UNIT_POS = MCA.ATTR_CHIP_UNIT_POS
          l_def_PORT_INDEX = l_def_POSITION%2
          l_def_NUM_RANKS = (l_TGT2_ATTR_EFF_NUM_RANKS_PER_DIMM[l_def_PORT_INDEX][0] +
                                    l_TGT2_ATTR_EFF_NUM_RANKS_PER_DIMM[l_def_PORT_INDEX][1])
          l_TGT2_ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM = MCS.ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM
          l_def_SLOT0_DENOMINATOR = ((l_TGT2_ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM[l_def_PORT_INDEX][0] ==
                                             0x0) | l_TGT2_ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM[l_def_PORT_INDEX][0])
          l_def_SLOT0_DRAM_STACK_HEIGHT = (l_TGT2_ATTR_EFF_NUM_RANKS_PER_DIMM[l_def_PORT_INDEX][0] /
                l_def_SLOT0_DENOMINATOR)
          l_def_is_dual_slot = ((l_TGT2_ATTR_EFF_NUM_RANKS_PER_DIMM[l_def_PORT_INDEX][0] > 0)
                                       && (l_TGT2_ATTR_EFF_NUM_RANKS_PER_DIMM[l_def_PORT_INDEX][1] > 0))
          l_def_refblock_off_special_case = (((l_def_is_dual_slot == 0)
                && (l_TGT2_ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM[l_def_PORT_INDEX][0] == 4))
                && (l_def_SLOT0_DRAM_STACK_HEIGHT == 2))
          l_TGT3_ATTR_ENABLE_MEM_EARLY_DATA_SCOM = SYSTEM.ATTR_ENABLE_MEM_EARLY_DATA_SCOM
          l_TGT4_ATTR_CHIP_EC_FEATURE_HW401780 = !!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!
          // Regs for ID=5 below are not documented
          *0x5010823 =        // P9N2_MCS_PORT02_MCPERF0
              [22-27] = 0x20

          *0x5010824 =
              [0-2]   = 1
              [3-5]   = 3
              [6-8]   = 5
              [9-11]  = 7
              [13-15] = 0b000 : if (l_TGT2_ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM[l_def_PORT_INDEX][0] == 1),
                        0b001 : if (l_TGT2_ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM[l_def_PORT_INDEX][0] == 2),
                        0b100 : if (l_TGT2_ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM[l_def_PORT_INDEX][0] == 4),
              [13-15] |= 0b010 : if (l_def_is_dual_slot && l_TGT2_ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM[l_def_PORT_INDEX][0] != 4)
              [16] = 1 : if (1 < l_def_NUM_RANKS <= 8 && l_def_refblock_off_special_case) else 0  // MC01_PORT0_ATCL_CL_CLSCOM_MCPERF2_ENABLE_REFRESH_BLOCK_SQ
              [17] = 1 : if (1 < l_def_NUM_RANKS <= 8 && l_def_refblock_off_special_case) else 0  // MC01_PORT0_ATCL_CL_CLSCOM_MCPERF2_ENABLE_REFRESH_BLOCK_NSQ
              [18]    = 0     // MC01_PORT0_ATCL_CL_CLSCOM_MCPERF2_ENABLE_REFRESH_BLOCK_DISP
              [28-31] = 0b0100
              [50-54] = 0b11100
              [61] = 1 : if (l_TGT3_ATTR_ENABLE_MEM_EARLY_DATA_SCOM == fapi2::ENUM_..._ON) else 0 // MC01_PORT0_ATCL_CL_CLSCOM_MCPERF2_EN_ALT_ECR_ERR

          *0x5010825 =
              [1]     = 0     // MC01_PORT0_ATCL_CL_CLSCOM_MCAMOC_FORCE_PF_DROP0_OFF
              [4-28]  = 0x19fffff : if (l_TGT4_ATTR_CHIP_EC_FEATURE_HW401780 != 1) else 0
              [29-31] = 1     // MC01_PORT0_ATCL_CL_CLSCOM_MCAMOC_AMO_SIZE_SELECT_128B_RW_64B_DATA

          *0x5010826 =
              [0-7]   = 1
              [8-15]  = l_def_MC_EPSILON_CFG_T0
              [16-23] = l_def_MC_EPSILON_CFG_T1
              [24-31] = l_def_MC_EPSILON_CFG_T1
              [32-39] = l_def_MC_EPSILON_CFG_T2
              [40-47] = l_def_MC_EPSILON_CFG_T2

          *0x5010827 =
              [0]     = 1   // MC01_PORT0_ATCL_CL_CLSCOM_MCBUSYQ_ENABLE_BUSY_COUNTERS_ON
              [1-3]   = 1   // MC01_PORT0_ATCL_CL_CLSCOM_MCBUSYQ_BUSY_COUNTER_WINDOW_SELECT_1024_CYCLES
              [4-13]  = 38
              [14-23] = 51
              [24-33] = 64

          *0x501082b =
              [31] = 1      // MC01_PORT0_ATCL_CL_CLSCOM_MCPERF3_ENABLE_CL0
              [41] = 1      // MC01_PORT0_ATCL_CL_CLSCOM_MCPERF3_ENABLE_AMO_MSI_RMW_ONLY
              [43] = 1 : if (l_TGT3_ATTR_ENABLE_MEM_EARLY_DATA_SCOM == fapi2::ENUM_..._OFF) else 0 // MC01_PORT0_ATCL_CL_CLSCOM_MCPERF3_ENABLE_CP_M_MDI0_LOCAL_ONLY
              [44] = 1      // MC01_PORT0_ATCL_CL_CLSCOM_MCPERF3_DISABLE_WRTO_IG
              [45] = 1

          MC01.PORT0.SRQ.MBA_DSM0Q =       // 0x701090a
              [0-5]   MBA_DSM0Q_CFG_RODT_START_DLY = l_TGT2_ATTR_EFF_DRAM_CL[l_def_PORT_INDEX] -
                          l_TGT2_ATTR_EFF_DRAM_CWL[l_def_PORT_INDEX]
              [6-11]  MBA_DSM0Q_CFG_RODT_END_DLY = l_TGT2_ATTR_EFF_DRAM_CL[l_def_PORT_INDEX] -
                          l_TGT2_ATTR_EFF_DRAM_CWL[l_def_PORT_INDEX] + 5
              [12-17] MBA_DSM0Q_CFG_WODT_START_DLY = 0
              [18-23] MBA_DSM0Q_CFG_WODT_END_DLY = 5
              [24-29] MBA_DSM0Q_CFG_WRDONE_DLY = 24
              [30-35] MBA_DSM0Q_CFG_WRDATA_DLY = (l_TGT2_ATTR_EFF_DRAM_CWL[l_def_PORT_INDEX] +
                        l_TGT2_ATTR_MSS_EFF_DPHY_WLO[l_def_PORT_INDEX]) - 8
              [36-41] MBA_DSM0Q_CFG_RDTAG_DLY =
                if (TGT2_ATTR_EFF_DIMM_TYPE[l_def_PORT_INDEX][0] == 1):
                  MSS_FREQ_EQ_1866:               TGT2_ATTR_EFF_DRAM_CL[l_def_PORT_INDEX] + 7
                  MSS_FREQ_EQ_2133:               TGT2_ATTR_EFF_DRAM_CL[l_def_PORT_INDEX] + 7
                  MSS_FREQ_EQ_2400 && NOT_NVDIMM: TGT2_ATTR_EFF_DRAM_CL[l_def_PORT_INDEX] + 8
                  MSS_FREQ_EQ_2400 && IS_NVDIMM:  TGT2_ATTR_EFF_DRAM_CL[l_def_PORT_INDEX] + 9
                  MSS_FREQ_EQ_2666:               TGT2_ATTR_EFF_DRAM_CL[l_def_PORT_INDEX] + 9
                if (TGT2_ATTR_EFF_DIMM_TYPE[l_def_PORT_INDEX][0] == 3):
                  MSS_FREQ_EQ_1866:               TGT2_ATTR_EFF_DRAM_CL[l_def_PORT_INDEX] + 9
                  MSS_FREQ_EQ_2133:               TGT2_ATTR_EFF_DRAM_CL[l_def_PORT_INDEX] + 9
                  MSS_FREQ_EQ_2400:               TGT2_ATTR_EFF_DRAM_CL[l_def_PORT_INDEX] + 10
                  MSS_FREQ_EQ_2666:               TGT2_ATTR_EFF_DRAM_CL[l_def_PORT_INDEX] + 11

          MC01.PORT0.SRQ.MBA_TMR0Q =      // 0x701090b
              [0-3]   MBA_TMR0Q_RRDM_DLY =    l_def_RANK_SWITCH_TCK + 4
              [4-7]   MBA_TMR0Q_RRSMSR_DLY =  4
              [8-11]  MBA_TMR0Q_RRSMDR_DLY =  4
              [12-15] MBA_TMR0Q_RROP_DLY =    l_TGT2_ATTR_EFF_DRAM_TCCD_L[l_def_PORT_INDEX]
              [16-19] MBA_TMR0Q_WWDM_DLY =    l_def_RANK_SWITCH_TCK + 4
              [20-23] MBA_TMR0Q_WWSMSR_DLY =  4
              [24-27] MBA_TMR0Q_WWSMDR_DLY =  4
              [28-31] MBA_TMR0Q_WWOP_DLY =    l_TGT2_ATTR_EFF_DRAM_TCCD_L[l_def_PORT_INDEX]
              [32-36] MBA_TMR0Q_RWDM_DLY =    l_TGT2_ATTR_EFF_DRAM_CL[l_def_PORT_INDEX] + 4 +
                        l_def_BUS_TURNAROUND_TCK - l_TGT2_ATTR_EFF_DRAM_CWL[l_def_PORT_INDEX]
              [37-41] MBA_TMR0Q_RWSMSR_DLY =  l_TGT2_ATTR_EFF_DRAM_CL[l_def_PORT_INDEX] + 4 +
                        l_def_BUS_TURNAROUND_TCK - l_TGT2_ATTR_EFF_DRAM_CWL[l_def_PORT_INDEX]
              [42-46] MBA_TMR0Q_RWSMDR_DLY =  l_TGT2_ATTR_EFF_DRAM_CL[l_def_PORT_INDEX] + 4 +
                        l_def_BUS_TURNAROUND_TCK - l_TGT2_ATTR_EFF_DRAM_CWL[l_def_PORT_INDEX]
              if (l_TGT2_ATTR_EFF_DIMM_TYPE[l_def_PORT_INDEX][0] != 1)
                [32-36] += 6
                [37-41] += 6
                [42-46] += 6
              [47-50] MBA_TMR0Q_WRDM_DLY =    l_TGT2_ATTR_EFF_DRAM_CWL[l_def_PORT_INDEX] + 4 +
                    l_def_BUS_TURNAROUND_TCK - l_TGT2_ATTR_EFF_DRAM_CL[l_def_PORT_INDEX]
              [51-56] MBA_TMR0Q_WRSMSR_DLY =  l_TGT2_ATTR_EFF_DRAM_CWL[l_def_PORT_INDEX] + 4 +
                    l_TGT2_ATTR_EFF_DRAM_TWTR_S[l_def_PORT_INDEX]
              [57-62] MBA_TMR0Q_WRSMDR_DLY =  l_TGT2_ATTR_EFF_DRAM_CWL[l_def_PORT_INDEX] + 4 +
                    l_TGT2_ATTR_EFF_DRAM_TWTR_S[l_def_PORT_INDEX]

          MC01.PORT0.SRQ.MBA_TMR1Q =      // 0x701090c
              [0-3]   MBA_TMR1Q_RRSBG_DLY =   l_TGT2_ATTR_EFF_DRAM_TCCD_L[l_def_PORT_INDEX]
              [4-9]   MBA_TMR1Q_WRSBG_DLY =   l_TGT2_ATTR_EFF_DRAM_CWL[l_def_PORT_INDEX] + 4 +
                    l_TGT2_ATTR_EFF_DRAM_TWTR_L[l_def_PORT_INDEX]
              [10-15] MBA_TMR1Q_CFG_TFAW =    l_TGT2_ATTR_EFF_DRAM_TFAW[l_def_PORT_INDEX]
              [16-20] MBA_TMR1Q_CFG_TRCD =    l_TGT2_ATTR_EFF_DRAM_TRCD[l_def_PORT_INDEX]
              [21-25] MBA_TMR1Q_CFG_TRP =     l_TGT2_ATTR_EFF_DRAM_TRP[l_def_PORT_INDEX]
              [26-31] MBA_TMR1Q_CFG_TRAS =    l_TGT2_ATTR_EFF_DRAM_TRAS[l_def_PORT_INDEX]
              [41-47] MBA_TMR1Q_CFG_WR2PRE =  l_TGT2_ATTR_EFF_DRAM_CWL[l_def_PORT_INDEX] + 4 +
                    l_TGT2_ATTR_EFF_DRAM_TWR[l_def_PORT_INDEX]
              [48-51] MBA_TMR1Q_CFG_RD2PRE =  l_TGT2_ATTR_EFF_DRAM_TRTP[l_def_PORT_INDEX]
              [52-55] MBA_TMR1Q_TRRD =        l_TGT2_ATTR_EFF_DRAM_TRRD_S[l_def_PORT_INDEX]
              [56-59] MBA_TMR1Q_TRRD_SBG =    l_TGT2_ATTR_EFF_DRAM_TRRD_L[l_def_PORT_INDEX]
              [60-63] MBA_TMR1Q_CFG_ACT_TO_DIFF_RANK_DLY =
                MSS_FREQ_EQ_1866: 8
                MSS_FREQ_EQ_2133: 9
                MSS_FREQ_EQ_2400: 10
                MSS_FREQ_EQ_2666: 11

          MC01.PORT0.SRQ.MBA_WRQ0Q =      // 0x701090d
              [5]     MBA_WRQ0Q_CFG_WRQ_FIFO_MODE =               l_TGT1_ATTR_MSS_REORDER_QUEUE_SETTING
              [6]   MBA_WRQ0Q_CFG_DISABLE_WR_PG_MODE =            1
              [55-58] MBA_WRQ0Q_CFG_WRQ_ACT_NUM_WRITES_PENDING =  8

          MC01.PORT0.SRQ.MBA_RRQ0Q =      // 0x701090e
              [6]     MBA_RRQ0Q_CFG_RRQ_FIFO_MODE =             l_TGT1_ATTR_MSS_REORDER_QUEUE_SETTING
              [57-60] MBA_RRQ0Q_CFG_RRQ_ACT_NUM_READS_PENDING = 8

          MC01.PORT0.SRQ.MBA_FARB0Q =     // 0x7010913
              if (l_TGT3_ATTR_MSS_MRW_DRAM_2N_MODE == 0x02 || (l_TGT3_ATTR_MSS_MRW_DRAM_2N_MODE == 0x00 && l_TGT2_ATTR_MSS_VPD_MR_MC_2N_MODE_AUTOSET == 0x02))
                [17] MBA_FARB0Q_CFG_2N_ADDR =         1
              [38] MBA_FARB0Q_CFG_PARITY_AFTER_CMD =  1
              [61-63] MBA_FARB0Q_CFG_OPT_RD_SIZE =    3

          MC01.PORT0.SRQ.MBA_FARB1Q =     // 0x7010914
              [0-2]   MBA_FARB1Q_CFG_SLOT0_S0_CID = 0
              [3-5]   MBA_FARB1Q_CFG_SLOT0_S1_CID = 4
              [6-8]   MBA_FARB1Q_CFG_SLOT0_S2_CID = 2
              [9-11]  MBA_FARB1Q_CFG_SLOT0_S3_CID = 6
              if (l_def_SLOT0DRAM_STACK_HEIGHT == 8)
                [12-14] MBA_FARB1Q_CFG_SLOT0_S4_CID =   1
                [15-17] MBA_FARB1Q_CFG_SLOT0_S5_CID =   5
                [18-20] MBA_FARB1Q_CFG_SLOT0_S6_CID =   3
                [21-23] MBA_FARB1Q_CFG_SLOT0_S7_CID =   7
              else
                [12-14] MBA_FARB1Q_CFG_SLOT0_S4_CID =   0
                [15-17] MBA_FARB1Q_CFG_SLOT0_S5_CID =   4
                [18-20] MBA_FARB1Q_CFG_SLOT0_S6_CID =   2
                [21-23] MBA_FARB1Q_CFG_SLOT0_S7_CID =   6
              if (l_def_MASTER_RANKS_DIMM0 == 4)
                [12-14] MBA_FARB1Q_CFG_SLOT0_S4_CID =   4     // TODO: test if all slots with 1x4R DIMMs works with that
              [24-26] MBA_FARB1Q_CFG_SLOT1_S0_CID = 0
              [27-29] MBA_FARB1Q_CFG_SLOT1_S1_CID = 4
              [30-32] MBA_FARB1Q_CFG_SLOT1_S2_CID = 2
              [33-35] MBA_FARB1Q_CFG_SLOT1_S3_CID = 6
              if (l_def_SLOT1DRAM_STACK_HEIGHT == 8)
                [36-38] MBA_FARB1Q_CFG_SLOT1_S4_CID =   1
                [39-41] MBA_FARB1Q_CFG_SLOT1_S5_CID =   5
                [42-44] MBA_FARB1Q_CFG_SLOT1_S6_CID =   3
                [45-47] MBA_FARB1Q_CFG_SLOT1_S7_CID =   7
              else
                [36-38] MBA_FARB1Q_CFG_SLOT1_S4_CID =   0
                [39-41] MBA_FARB1Q_CFG_SLOT1_S5_CID =   4
                [42-44] MBA_FARB1Q_CFG_SLOT1_S6_CID =   2
                [45-47] MBA_FARB1Q_CFG_SLOT1_S7_CID =   6
              if (l_def_MASTER_RANKS_DIMM1 == 4)
                [36-38] MBA_FARB1Q_CFG_SLOT1_S4_CID =   4     // TODO: test if all slots with 1x4R DIMMs works with that

          MC01.PORT0.SRQ.MBA_FARB2Q =       // 0x7010915
              F(X) = (((X >> 4) & 0xc) | ((X >> 2) & 0x3))    // Bits 0,1,4,5 of X
              [0-3]   MBA_FARB2Q_CFG_RANK0_RD_ODT = F(ATTR_MSS_VPD_MT_ODT_RD[l_def_PORT_INDEX][0][0])
              [4-7]   MBA_FARB2Q_CFG_RANK1_RD_ODT = F(ATTR_MSS_VPD_MT_ODT_RD[l_def_PORT_INDEX][0][1])
              [8-11]  MBA_FARB2Q_CFG_RANK2_RD_ODT = F(ATTR_MSS_VPD_MT_ODT_RD[l_def_PORT_INDEX][0][2])
              [12-15] MBA_FARB2Q_CFG_RANK3_RD_ODT = F(ATTR_MSS_VPD_MT_ODT_RD[l_def_PORT_INDEX][0][3])
              [16-19] MBA_FARB2Q_CFG_RANK4_RD_ODT = F(ATTR_MSS_VPD_MT_ODT_RD[l_def_PORT_INDEX][1][0])
              [20-23] MBA_FARB2Q_CFG_RANK5_RD_ODT = F(ATTR_MSS_VPD_MT_ODT_RD[l_def_PORT_INDEX][1][1])
              [24-27] MBA_FARB2Q_CFG_RANK6_RD_ODT = F(ATTR_MSS_VPD_MT_ODT_RD[l_def_PORT_INDEX][1][2])
              [28-31] MBA_FARB2Q_CFG_RANK7_RD_ODT = F(ATTR_MSS_VPD_MT_ODT_RD[l_def_PORT_INDEX][1][3])
              [32-35] MBA_FARB2Q_CFG_RANK0_WR_ODT = F(ATTR_MSS_VPD_MT_ODT_WR[l_def_PORT_INDEX][0][0])
              [36-39] MBA_FARB2Q_CFG_RANK1_WR_ODT = F(ATTR_MSS_VPD_MT_ODT_WR[l_def_PORT_INDEX][0][1])
              [40-43] MBA_FARB2Q_CFG_RANK2_WR_ODT = F(ATTR_MSS_VPD_MT_ODT_WR[l_def_PORT_INDEX][0][2])
              [44-47] MBA_FARB2Q_CFG_RANK3_WR_ODT = F(ATTR_MSS_VPD_MT_ODT_WR[l_def_PORT_INDEX][0][3])
              [48-51] MBA_FARB2Q_CFG_RANK4_WR_ODT = F(ATTR_MSS_VPD_MT_ODT_WR[l_def_PORT_INDEX][1][0])
              [52-55] MBA_FARB2Q_CFG_RANK5_WR_ODT = F(ATTR_MSS_VPD_MT_ODT_WR[l_def_PORT_INDEX][1][1])
              [56-59] MBA_FARB2Q_CFG_RANK6_WR_ODT = F(ATTR_MSS_VPD_MT_ODT_WR[l_def_PORT_INDEX][1][2])
              [60-63] MBA_FARB2Q_CFG_RANK7_WR_ODT = F(ATTR_MSS_VPD_MT_ODT_WR[l_def_PORT_INDEX][1][3])

          MC01.PORT0.SRQ.PC.MBAREF0Q =      // 0x7010932
              [5-7]   MBAREF0Q_CFG_REFRESH_PRIORITY_THRESHOLD = 3
              [8-18]  MBAREF0Q_CFG_REFRESH_INTERVAL =           l_def_REFRESH_INTERVAL
              [30-39] MBAREF0Q_CFG_TRFC =                       l_TGT2_ATTR_EFF_DRAM_TRFC[l_def_PORT_INDEX]
              [40-49] MBAREF0Q_CFG_REFR_TSV_STACK =             l_TGT2_ATTR_EFF_DRAM_TRFC_DLR[l_def_PORT_INDEX]
              [50-60] MBAREF0Q_CFG_REFR_CHECK_INTERVAL =        (l_def_REFRESH_INTERVAL * l_def_NUM_RANKS * 6) / 5

          MC01.PORT0.SRQ.PC.MBARPC0Q =      // 0x7010934
              [6-10]  MBARPC0Q_CFG_PUP_AVAIL =
                MSS_FREQ_EQ_1866: 6
                MSS_FREQ_EQ_2133: 7
                MSS_FREQ_EQ_2400: 8
                MSS_FREQ_EQ_2666: 9
              [11-15] MBARPC0Q_CFG_PDN_PUP =
                MSS_FREQ_EQ_1866: 5
                MSS_FREQ_EQ_2133: 6
                MSS_FREQ_EQ_2400: 6
                MSS_FREQ_EQ_2666: 7
              [16-20] MBARPC0Q_CFG_PUP_PDN =
                MSS_FREQ_EQ_1866: 5
                MSS_FREQ_EQ_2133: 6
                MSS_FREQ_EQ_2400: 6
                MSS_FREQ_EQ_2666: 7
              [21] MBARPC0Q_RESERVED_21 =         // MCP_PORT0_SRQ_PC_MBARPC0Q_CFG_QUAD_RANK_ENC
                (l_def_MASTER_RANKS_DIMM0 == 4): 1
                (l_def_MASTER_RANKS_DIMM0 != 4): 0

          MC01.PORT0.SRQ.PC.MBASTR0Q =      // 0x7010935
              [12-16] MBASTR0Q_CFG_TCKESR = 5
              [17-21] MBASTR0Q_CFG_TCKSRE =
                MSS_FREQ_EQ_1866: 10
                MSS_FREQ_EQ_2133: 11
                MSS_FREQ_EQ_2400: 12
                MSS_FREQ_EQ_2666: 14
              [22-26] MBASTR0Q_CFG_TCKSRX =
                MSS_FREQ_EQ_1866: 10
                MSS_FREQ_EQ_2133: 11
                MSS_FREQ_EQ_2400: 12
                MSS_FREQ_EQ_2666: 14
              [27-37] MBASTR0Q_CFG_TXSDLL =
                MSS_FREQ_EQ_1866: 597
                MSS_FREQ_EQ_2133: 768
                MSS_FREQ_EQ_2400: 768
                MSS_FREQ_EQ_2666: 939
              [46-56] MBASTR0Q_CFG_SAFE_REFRESH_INTERVAL = l_def_REFRESH_INTERVAL

          MC01.PORT0.ECC64.SCOM.RECR =      // 0x7010a0a
              [16-18] MBSECCQ_VAL_TO_DATA_DELAY =
                l_TGT4_ATTR_MC_SYNC_MODE == 1:  5
                l_def_mn_freq_ratio < 915:      3
                l_def_mn_freq_ratio < 1150:     4
                l_def_mn_freq_ratio < 1300:     5
                l_def_mn_freq_ratio >= 1300:    6
              [19]    MBSECCQ_DELAY_VALID_1X =  0
              [20-21] MBSECCQ_NEST_VAL_TO_DATA_DELAY =
                l_TGT4_ATTR_MC_SYNC_MODE == 1:  1
                l_def_mn_freq_ratio < 1040:     1
                l_def_mn_freq_ratio < 1150:     0
                l_def_mn_freq_ratio < 1215:     1
                l_def_mn_freq_ratio < 1300:     0
                l_def_mn_freq_ratio < 1400:     1
                l_def_mn_freq_ratio >= 1400:    0
              [22]    MBSECCQ_DELAY_NONBYPASS =
                l_TGT4_ATTR_MC_SYNC_MODE == 1:  0
                l_def_mn_freq_ratio < 1215:     0
                l_def_mn_freq_ratio >= 1215:    1
              [40]    MBSECCQ_RESERVED_36_43 =        // MCP_PORT0_ECC64_ECC_SCOM_MBSECCQ_BYPASS_TENURE_3
                l_TGT4_ATTR_MC_SYNC_MODE == 1:  0
                l_TGT4_ATTR_MC_SYNC_MODE == 0:  1

          MC01.PORT0.ECC64.SCOM.DBGR =      // 0x7010a0b
              [9]     DBGR_ECC_WAT_ACTION_SELECT =  0
              [10-11] DBGR_ECC_WAT_SOURCE =         0

          MC01.PORT0.WRITE.WRTCFG =         // 0x7010a38
              [9] = 1     // MCP_PORT0_WRITE_NEW_WRITE_64B_MODE   this is marked as RO const 0 for bits 8-63 in docs!

      - mca thermal throttle scominit
        mss::mc::thermal_throttle_scominit(MCA)
          set_pwr_cntrl_reg(MCA)
            MC01.PORT0.SRQ.PC.MBARPC0Q =      // 0x7010934
              [3-5]   MBARPC0Q_CFG_MIN_MAX_DOMAINS =                    0
              [22]    MBARPC0Q_CFG_MIN_DOMAIN_REDUCTION_ENABLE =
                ATTR_MSS_MRW_POWER_CONTROL_REQUESTED == PD_AND_STR_OFF: 0
                else:                                                   1
              [23-32] MBARPC0Q_CFG_MIN_DOMAIN_REDUCTION_TIME =          959
          set_str_reg(MCA)
            MC01.PORT0.SRQ.PC.MBASTR0Q =      // 0x7010935
              [0]     MBASTR0Q_CFG_STR_ENABLE =
                ATTR_MSS_MRW_POWER_CONTROL_REQUESTED == PD_AND_STR:           1
                ATTR_MSS_MRW_POWER_CONTROL_REQUESTED == PD_AND_STR_CLK_STOP:  1
                ATTR_MSS_MRW_POWER_CONTROL_REQUESTED == POWER_DOWN:           0
                ATTR_MSS_MRW_POWER_CONTROL_REQUESTED == PD_AND_STR_OFF:       0
              [2-11]  MBASTR0Q_CFG_ENTER_STR_TIME =                           1023
          set_nm_support(MCA)
            MC01.PORT1.SRQ.MBA_FARB3Q =       // 0x7010956
              [0-14]  MBA_FARB3Q_CFG_NM_N_PER_SLOT = ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT[mss::index(MCA)]
              [15-30] MBA_FARB3Q_CFG_NM_N_PER_PORT = ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT[mss::index(MCA)]
              [31-44] MBA_FARB3Q_CFG_NM_M =          ATTR_MSS_MRW_MEM_M_DRAM_CLOCKS
              [45-47] MBA_FARB3Q_CFG_NM_RAS_WEIGHT = 0
              [48-50] MBA_FARB3Q_CFG_NM_CAS_WEIGHT = 1
              // Set to disable permanently due to hardware design bug (HW403028) that won't be changed
              [53]    MBA_FARB3Q_CFG_NM_CHANGE_AFTER_SYNC = 0
          set_safemode_throttles(MCA)
            MC01.PORT1.SRQ.MBA_FARB4Q =       // 0x7010957
              [27-41] MBA_FARB4Q_EMERGENCY_N = ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT[mss::index(MCA)]  // BUG? var name says per_slot...
              [42-55] MBA_FARB4Q_EMERGENCY_M = ATTR_MSS_MRW_MEM_M_DRAM_CLOCKS
    > }
    - phy scominit // can do even when no DIMMs
      p9n_ddrphy_scom(MCA, MCBIST.getParent<PROC_CHIP>)
        --------------------------------------------------------
        IOM0.DDRPHY_DP16_DLL_VREG_CONTROL0_P0_{0,1,2,3,4} =     // 0x8000002a0701103f, +0x0400_0000_0000   // this seems strange...
            [48-50] RXREG_VREG_COMPCON_DC = 3
            [52-59] = 0x74:
                    [53-55] RXREG_VREG_DRVCON_DC =  0x7
                    [56-58] RXREG_VREG_REF_SEL_DC = 0x2
            [62-63] = 0:
                    [62] DLL_DRVREN_MODE =      POWER8 mode (thermometer style, enabling all drivers up to the one that is used)
                    [63] DLL_CAL_CKTS_ACTIVE =  After VREG calibration, some analog circuits are powered down

        IOM0.DDRPHY_DP16_DLL_VREG_CONTROL1_P0_{0,1,2,3,4} =     // 0x8000002b0701103f, +0x0400_0000_0000   // this seems strange...
            [48-50] RXREG_VREG_COMPCON_DC = 3
            [52-59] = 0x74:
                    [53-55] RXREG_VREG_DRVCON_DC =  0x7
                    [56-58] RXREG_VREG_REF_SEL_DC = 0x2
            [62-63] = 0:
                    [62] DLL_DRVREN_MODE =      POWER8 mode (thermometer style, enabling all drivers up to the one that is used)
                    [63] DLL_CAL_CKTS_ACTIVE =  After VREG calibration, some analog circuits are powered down

        IOM0.DDRPHY_DP16_WRCLK_PR_P0_{0,1,2,3,4} =              // 0x800000740701103f, +0x0400_0000_0000
            // For zero delay simulations, or simulations where the delay of the SysClk tree and the WrClk tree are equal, set this field to 60h
            [49-55] TSYS_WRCLK = 0x60

        IOM0.DDRPHY_DP16_IO_TX_CONFIG0_P0_{0,1,2,3,4} =         // 0x800000750701103f, +0x0400_0000_0000
            [48-51] STRENGTH =                    0x4 // 2400 MT/s
            [52]    DD2_RESET_READ_FIX_DISABLE =  0   // Enable the DD2 function to remove the register reset on read feature on status registers

        IOM0.DDRPHY_DP16_DLL_CONFIG1_P0_{0,1,2,3,4} =           // 0x800000770701103f, +0x0400_0000_0000
            [48-63] = 0x0006:
                    [48-51] HS_DLLMUX_SEL_0_0_3 = 0
                    [53-56] HS_DLLMUX_SEL_1_0_3 = 0
                    [61]    S0INSDLYTAP =         1 // For proper functional operation, this bit must be 0b
                    [62]    S1INSDLYTAP =         1 // For proper functional operation, this bit must be 0b

        IOM0.DDRPHY_DP16_IO_TX_FET_SLICE_P0_{0,1,2,3,4} =       // 0x800000780701103f, +0x0400_0000_0000
            [48-63] = 0x7f7f:
                    [59-55] EN_SLICE_N_WR = 0x7f
                    [57-63] EN_SLICE_P_WR = 0x7f
        ----------------------------------------------------------------

a)      IOM0.DDRPHY_ADR_BIT_ENABLE_P0_ADR0 =        // 0x800040000701103f     // can all 'a)' be reordered and merged into loop?
            [48-63] = 0xffff

a)      IOM0.DDRPHY_ADR_BIT_ENABLE_P0_ADR1 =        // 0x800044000701103f
            [48-63] = 0xffff

        IOM0.DDRPHY_ADR_DIFFPAIR_ENABLE_P0_ADR1 =   // 0x800044010701103f
            [48-63] = 0x5000:
                    [49] DI_ADR2_ADR3: 1 = Lanes 2 and 3 are a differential clock pair
                    [51] DI_ADR6_ADR7: 1 = Lanes 6 and 7 are a differential clock pair

        IOM0.DDRPHY_ADR_DELAY1_P0_ADR1 =            // 0x800044050701103f
            [48-63] = 0x4040:
                    [49-55] ADR_DELAY2 = 0x40
                    [57-63] ADR_DELAY3 = 0x40

        IOM0.DDRPHY_ADR_DELAY3_P0_ADR1 =            // 0x800044070701103f
            [48-63] = 0x4040:
                    [49-55] ADR_DELAY6 = 0x40
                    [57-63] ADR_DELAY7 = 0x40

a)      IOM0.DDRPHY_ADR_BIT_ENABLE_P0_ADR2 =        // 0x800048000701103f
            [48-63] = 0xffff

a)      IOM0.DDRPHY_ADR_BIT_ENABLE_P0_ADR3 =        // 0x80004c000701103f
            [48-63] = 0xffff

        ------------------------------------------------
        IOM0.DDRPHY_ADR_DLL_VREG_CONFIG_1_P0_ADR32S{0,1} =    // 0x800080310701103f, +0x0400_0000_0000
            [48-63] = 0x0008:
                    [48-51] HS_DLLMUX_SEL_0_3 = 0
                    [59-62] STRENGTH =          4 // 2400 MT/s

        IOM0.DDRPHY_ADR_MCCLK_WRCLK_PR_STATIC_OFFSET_P0_ADR32S{0,1} =     // 0x800080330701103f, +0x0400_0000_0000
            [48-63] = 0x6000
                      // For zero delay simulations, or simulations where the delay of the SysClk tree and the WrClk tree are equal, set this field to 60h
                      [49-55] TSYS_WRCLK = 0x60

        IOM0.DDRPHY_ADR_DLL_VREG_CONTROL_P0_ADR32S{0,1} =     // 0x8000803d0701103f, +0x0400_0000_0000
            [48-50] RXREG_VREG_COMPCON_DC =         3
            [52-59] = 0x74:
                    [53-55] RXREG_VREG_DRVCON_DC =  0x7
                    [56-58] RXREG_VREG_REF_SEL_DC = 0x2
            [63] DLL_CAL_CKTS_ACTIVE =  0   // After VREG calibration, some analog circuits are powered down
        ------------------------------------------------

        IOM0.DDRPHY_PC_CONFIG0_P0 =             // 0x8000c00c0701103f
            [48-63] = 0x0202:
                    [48-51] PDA_ENABLE_OVERRIDE =     0
                    [52]    2TCK_PREAMBLE_ENABLE =    0
                    [53]    PBA_ENABLE =              0
                    [54]    DDR4_CMD_SIG_REDUCTION =  1
                    [55]    SYSCLK_2X_MEMINTCLKO =    0
                    [56]    RANK_OVERRIDE =           0
                    [57-59] RANK_OVERRIDE_VALUE =     0
                    [60]    LOW_LATENCY =             0
                    [61]    DDR4_IPW_LOOP_DIS =       0
                    [62]    DDR4_VLEVEL_BANK_GROUP =  1
                    [63]    VPROTH_PSEL_MODE =        0

  p9n_mcbist_scom(MCBIST)
    MC01.MCBIST.MBA_SCOMFIR.WATCFG0AQ =         // 0x7012380
        [0-47]  WATCFG0AQ_CFG_WAT_EVENT_SEL =  0x400000000000

    MC01.MCBIST.MBA_SCOMFIR.WATCFG0BQ =         // 0x7012381
        [0-43]  WATCFG0BQ_CFG_WAT_MSKA =  0x3fbfff
        [44-60] WATCFG0BQ_CFG_WAT_CNTL =  0x10000

    MC01.MCBIST.MBA_SCOMFIR.WATCFG0DQ =         // 0x7012383
        [0-43]  WATCFG0DQ_CFG_WAT_PATA =  0x80200004000

    MC01.MCBIST.MBA_SCOMFIR.WATCFG3AQ =         // 0x701238f
        [0-47]  WATCFG3AQ_CFG_WAT_EVENT_SEL = 0x800000000000

    MC01.MCBIST.MBA_SCOMFIR.WATCFG3BQ =         // 0x7012390
        [0-43]  WATCFG3BQ_CFG_WAT_MSKA =  0xfffffffffff
        [44-60] WATCFG3BQ_CFG_WAT_CNTL =  0x10400

    MC01.MCBIST.MBA_SCOMFIR.MCBCFGQ =           // 0x70123e0
        [36]    MCBCFGQ_CFG_LOG_COUNTS_IN_TRACE = 0

    MC01.MCBIST.MBA_SCOMFIR.DBGCFG0Q =          // 0x70123e8
        [0]     DBGCFG0Q_CFG_DBG_ENABLE =         1
        [23-33] DBGCFG0Q_CFG_DBG_PICK_MCBIST01 =  0x780

    MC01.MCBIST.MBA_SCOMFIR.DBGCFG1Q =          // 0x70123e9
        [0]     DBGCFG1Q_CFG_WAT_ENABLE = 1

    MC01.MCBIST.MBA_SCOMFIR.DBGCFG2Q =          // 0x70123ea
        [0-19]  DBGCFG2Q_CFG_WAT_LOC_EVENT0_SEL = 0x10000
        [20-39] DBGCFG2Q_CFG_WAT_LOC_EVENT1_SEL = 0x08000

    MC01.MCBIST.MBA_SCOMFIR.DBGCFG3Q =          // 0x70123eb
        [20-22] DBGCFG3Q_CFG_WAT_GLOB_EVENT0_SEL =      0x4
        [23-25] DBGCFG3Q_CFG_WAT_GLOB_EVENT1_SEL =      0x4
        [37-40] DBGCFG3Q_CFG_WAT_ACT_SET_SPATTN_PULSE = 0x4

  - Initialize via scoms for non-static PHY items
    mss::phy_scominit(MCBIST)         // Freq is set per MCBIST, can we get better granularity?
      reset_io_tx_config0
        // These registers were already modified by p9n_ddrphy_scom. Can we set proper strength already there?
        IOM0.DDRPHY_DP16_IO_TX_CONFIG0_P0_{0,1,2,3,4} =     // 0x800000750701103f, +0x0400_0000_0000
            [48-51] STRENGTH =
                MSS_FREQ_EQ_1866: 1
                MSS_FREQ_EQ_2133: 2
                MSS_FREQ_EQ_2400: 4
                MSS_FREQ_EQ_2666: 8

      reset_dll_vreg_config1
        // These registers were already modified by p9n_ddrphy_scom. Can we set proper strength already there?
        IOM0.DDRPHY_ADR_DLL_VREG_CONFIG_1_P0_ADR32S{0,1} =  // 0x800080310701103f, +0x0400_0000_0000
            [59-62] STRENGTH =
                MSS_FREQ_EQ_1866: 1
                MSS_FREQ_EQ_2133: 2
                MSS_FREQ_EQ_2400: 4
                MSS_FREQ_EQ_2666: 8

      for each functional MCA:
        if (count_dimm(MCA) == 0) continue
        set_rank_pairs
          // TODO: assumes non-LR DIMMs (platform wiki) and no ATTR_EFF_RANK_GROUP_OVERRIDE (default in hb_temp_defaults.xml), add if needed (get_rank_pair_assignments)
          IOM0.DDRPHY_PC_RANK_PAIR0_P0 =      // 0x8000C0020701103F
              // TODO: re-check whether these numbers are correct. Some assumptions and simplifications were made here
              [48-63] = 0x1537 & F[rank_count]:     // F = {0, 0xf000, 0xf0f0, 0xfff0, 0xffff}
                  [48-50] RANK_PAIR0_PRI = 0
                  [51]    RANK_PAIR0_PRI_V = 1: if (rank_count >= 1)
                  [52-54] RANK_PAIR0_SEC = 2
                  [55]    RANK_PAIR0_SEC_V = 1: if (rank_count >= 3)
                  [56-58] RANK_PAIR1_PRI = 1
                  [59]    RANK_PAIR1_PRI_V = 1: if (rank_count >= 2)
                  [60-62] RANK_PAIR1_SEC = 3
                  [63]    RANK_PAIR1_SEC_V = 1: if (rank_count == 4)
          IOM0.DDRPHY_PC_RANK_PAIR1_P0 =      // 0x8000C0030701103F
              [48-63] = 0x1537 & F[rank_count]:     // F = {0, 0xf000, 0xf0f0, 0xfff0, 0xffff}
                  [48-50] RANK_PAIR2_PRI = 0
                  [51]    RANK_PAIR2_PRI_V = 1: if (rank_count >= 1)
                  [52-54] RANK_PAIR2_SEC = 2
                  [55]    RANK_PAIR2_SEC_V = 1: if (rank_count >= 3)
                  [56-58] RANK_PAIR3_PRI = 1
                  [59]    RANK_PAIR3_PRI_V = 1: if (rank_count >= 2)
                  [60-62] RANK_PAIR3_SEC = 3
                  [63]    RANK_PAIR3_SEC_V = 1: if (rank_count == 4)
          IOM0.DDRPHY_PC_RANK_PAIR2_P0 =      // 0x8000C0300701103F
              [48-63] = 0x1537 & F[rank_count]:     // F = {0, 0xf000, 0xf0f0, 0xfff0, 0xffff}
                  [48-50] RANK_PAIR0_TER = 0
                  [51]    RANK_PAIR0_TER_V = 1: if (rank_count >= 1)
                  [52-54] RANK_PAIR0_QUA = 2
                  [55]    RANK_PAIR0_QUA_V = 1: if (rank_count >= 3)
                  [56-58] RANK_PAIR1_TER = 1
                  [59]    RANK_PAIR1_TER_V = 1: if (rank_count >= 2)
                  [60-62] RANK_PAIR1_QUA = 3
                  [63]    RANK_PAIR1_QUA_V = 1: if (rank_count == 4)
          IOM0.DDRPHY_PC_RANK_PAIR3_P0 =      // 0x8000C0310701103F
              [48-63] = 0x1537 & F[rank_count]:     // F = {0, 0xf000, 0xf0f0, 0xfff0, 0xffff}
                  [48-50] RANK_PAIR2_TER = 0
                  [51]    RANK_PAIR2_TER_V = 1: if (rank_count >= 1)
                  [52-54] RANK_PAIR2_QUA = 2
                  [55]    RANK_PAIR2_QUA_V = 1: if (rank_count >= 3)
                  [56-58] RANK_PAIR3_TER = 1
                  [59]    RANK_PAIR3_TER_V = 1: if (rank_count >= 2)
                  [60-62] RANK_PAIR3_QUA = 3
                  [63]    RANK_PAIR3_QUA_V = 1: if (rank_count == 4)
          IOM0.DDRPHY_PC_CSID_CFG_P0 =        // 0x8000C0330701103F
                  [0-63]  0xf000:
                      [48]  CS0_INIT_CAL_VALUE = 1
                      [49]  CS1_INIT_CAL_VALUE = 1
                      [50]  CS2_INIT_CAL_VALUE = 1
                      [51]  CS3_INIT_CAL_VALUE = 1
          IOM0.DDRPHY_PC_MIRROR_CONFIG_P0 =   // 0x8000C0110701103F
                  [all] = 0
                  // A rank is mirrored if all are true:
                  //  - the rank is valid (RANK_PAIRn_XXX_V ==    1)
                  //  - the rank is odd   (RANK_PAIRn_XXX[LSB] == 1)
                  //  - the mirror mode attribute is set for the rank's DIMM (set in src/import/chips/p9/procedures/hwp/memory/lib/dimm/eff_dimm.C from SPD[136])
                  //  - We are not in quad encoded mode (so not 0bxx11 for RC0D)
                  [48]    ADDR_MIRROR_RP0_PRI
                          ...
                  [55]    ADDR_MIRROR_RP3_SEC
                  [58]    ADDR_MIRROR_A3_A4 = 1
                  [59]    ADDR_MIRROR_A5_A6 = 1
                  [60]    ADDR_MIRROR_A7_A8 = 1
                  [61]    ADDR_MIRROR_A11_A13 = 1
                  [62]    ADDR_MIRROR_BA0_BA1 = 1
                  [63]    ADDR_MIRROR_BG0_BG1 = 1
          IOM0.DDRPHY_PC_RANK_GROUP_EXT_P0 =  // 0x8000C0350701103F
                  [all] = 0
                  // Same rules as above
                  [48]    ADDR_MIRROR_RP0_TER
                          ...
                  [55]    ADDR_MIRROR_RP3_QUA

        reset_data_bit_enable
          IOM0.DDRPHY_DP16_DQ_BIT_ENABLE0_P0_{0,1,2,3} =    // 0x800000000701103F, +0x0400_0000_0000
                  [all] = 0
                  [48-63] DATA_BIT_ENABLE_0_15 = 0xffff
          IOM0.DDRPHY_DP16_DQ_BIT_ENABLE0_P0_4 =            // 0x800010000701103F
                  [all] = 0
                  [48-63] DATA_BIT_ENABLE_0_15 = 0xff00
          IOM0.DDRPHY_DP16_DFT_PDA_CONTROL_P0_{0,1,2,3,4} = // 0x800000010701103F, +0x0400_0000_0000
                  // This reg is named MCA_DDRPHY_DP16_DATA_BIT_ENABLE1_P0_n in the code.
                  // BUG? Spec says bits [48-55] must remain at reset value, but code disagrees. Follow the code for now...
                  [all] = 0

        reset_bad_bits
          // TODO: this disables bad DQ (and DQS if all DQs are dead) bits, based on data saved in NVRAM during earlier trainings.
          // For now assume there are no bad DQ bits. We do not yet have PNOR NVRAM driver in coreboot anyway.
          // Regs touched: IOM0.DDRPHY_DP16_DQ_BIT_DISABLE_RP{0-3}_P0_{0-4}, IOM0.DDRPHY_DP16_DQS_BIT_DISABLE_RP{0-3}_P0_{0-4}
          // - Is it enough to leave reset values or do we have to set them to 0 explicitly?
          //   - Those bits are set to 1 during training for failed pins in calibration steps
          // - Can DQ(S) bits be "resurrected" later in the training or is the NVRAM data final?

        get_rank_pairs(MCA, l_pairs)
          // l_pairs holds 4 bits of useful information (rank 0,1,2,3 exists or not). It uses up to 4*sizeof(uint64) bytes
          // for this (plus vector overhead) when passed as an argument; a vector of 5 vectors of 5 such 4-element vectors
          // is used in const data section for this. There is also a function which main task is to convert 4/5 to 2/3 and
          // skip empty elements before returning final vector, so static const data cannot be reused.
          // TL;DR: this function and its data is a waste of space
          // See set_rank_pairs above, this function uses different path to get almost identical result. Why this overcomplication?
          l_pairs = vector of {0, 1, 2, 3}, skip entry(-ies) if rank count is <2, e.g.
                  {0,2}   - 1 ranks DIMM0, 1 ranks DIMM1
                  {0,2,3} - 1 ranks DIMM0, 2(3,4) ranks DIMM1
                  {0,1}   - 2(3,4) ranks DIMM0, 0 ranks DIMM1 etc.

        reset_write_clock_enable(MCA, l_pairs)    // Merge with next function
          for each rp in l_pairs:
            wrckl_enable =        // src/import/chips/p9/procedures/hwp/memory/lib/phy/dp16.C
              wrclk_enable_no_spare_x4[0]: if DRAM width = x4
              wrclk_enable_no_spare_x8[MCA.pos]: if DRAM width = x8
            for each reg in wrclk_enable:
              reg.first + (rp << 40) =    // IOM0.DDRPHY_DP16_WRCLK_EN_RP<rp>_P0_{0-4}            0x80000<rp>050701103F, +0x0400_0000_0000
                    [48-63] QUADx_CLKyy = reg.second  // different for each reg/port, but the same for read and write

        reset_read_clock_enable(MCA, l_pairs)
          for each rp in l_pairs:
            rdckl_enable =        // src/import/chips/p9/procedures/hwp/memory/lib/phy/dp16.C
              rdclk_enable_no_spare_x4[0]: if DRAM width = x4
              rdclk_enable_no_spare_x8[MCA.pos]: if DRAM width = x8
            for each reg in rdclk_enable:
              reg.first + (rp << 40) =    // IOM0.DDRPHY_DP16_READ_CLOCK_RANK_PAIR<rp>_P0_{0-4}   0x80000<rp>040701103F, +0x0400_0000_0000
                    [48-63] QUADx_CLKyy = reg.second  // different for each reg/port, but the same for read and write

        reset_rd_vref
          //       RD_VREF_DVDD * (100000 - ATTR_MSS_VPD_MT_VREF_MC_RD) / RD_VREF_DAC_STEP
          vref_bf =     12      * (100000 - ATTR_MSS_VPD_MT_VREF_MC_RD) / 6500
          IOM0.DDRPHY_DP16_RD_VREF_DAC_{0-7}_P0_{0-3},            // addresses are not regular for DAC
          IOM0.DDRPHY_DP16_RD_VREF_DAC_{0-3}_P0_4 =               // only half of last DP16 is used
                [49-55] BIT0_VREF_DAC = vref_bf
                [57-63] BIT1_VREF_DAC = vref_bf
          IOM0.DDRPHY_DP16_RD_VREF_CAL_EN_P0_{0-4}                // 0x800000760701103F, +0x0400_0000_0000
                [48-63] VREF_CAL_EN = ATTR_MSS_RDVREF_CAL_ENABLE    // enable = 0xffff, disable = 0x0000

        pc::reset
          // IOM0.DDRPHY_PC_CONFIG0_P0 (0x8000c00c0701103f) has been reset in p9n_ddrphy_scom()
          IOM0.DDRPHY_PC_CONFIG1_P0 =             // 0x8000c00d0701103f
                [48-51] WRITE_LATENCY_OFFSET =  ATTR_MSS_EFF_DPHY_WLO
                [52-55] READ_LATENCY_OFFSET =   ATTR_MSS_EFF_DPHY_RLO
                          // If the MRW states 'auto' we use what's in VPD, otherwise we use what's in the MRW
                          +1: if 2N mode (ATTR_MSS_VPD_MR_MC_2N_MODE_AUTOSET, ATTR_MSS_MRW_DRAM_2N_MODE)  // Gear-down mode in JEDEC
                // Assume no LRDIMM
                [59-61] MEMORY_TYPE =           0x5     // 0x7 for LRDIMM
                [62]    DDR4_LATENCY_SW =       1

          IOM0.DDRPHY_PC_ERROR_STATUS0_P0 =       // 0x8000C0120701103F
                [all]   0

          IOM0.DDRPHY_PC_INIT_CAL_ERROR_P0 =      // 0x8000C0180701103F
                [all]   0

        wc::reset
          IOM0.DDRPHY_WC_CONFIG0_P0 =             // 0x8000CC000701103F
                [all]   0
                // BUG? Mismatch between comment (-,-), code (+,+) and docs (-,+) for operations inside 'max'
                [48-55] TWLO_TWLOE =        12 + max((twldqsen - tmod), (twlo + twlow))
                                     + longest DQS delay in clocks (rounded up) + longest DQ delay in clocks (rounded up)
                [56]    WL_ONE_DQS_PULSE =  1
                [57-62] FW_WR_RD =          0x20      // "# dd0 = 17 clocks, now 32 from SWyatt"
                [63]    CUSTOM_INIT_WRITE = 1         // set to a 1 to get proper values for RD VREF

          IOM0.DDRPHY_WC_CONFIG1_P0 =             // 0x8000CC010701103F
                [all]   0
                [48-51] BIG_STEP =          7
                [52-54] SMALL_STEP =        0
                [55-60] WR_PRE_DLY =        0x2a (42)

          IOM0.DDRPHY_WC_CONFIG2_P0 =             // 0x8000CC020701103F
                [all]   0
                [48-51] NUM_VALID_SAMPLES = 5
                [52-57] FW_RD_WR =          max(tWTR + 11, AL + tRTP + 3)
                [58-61] IPW_WR_WR =         5     // results in 24 clock cycles

          IOM0.DDRPHY_WC_CONFIG3_P0 =             // 0x8000CC050701103F
                [all]   0
                [55-60] MRS_CMD_DQ_OFF =    0x3f

          IOM0.DDRPHY_WC_RTT_WR_SWAP_ENABLE_P0    // 0x8000CC060701103F
                [48]    WL_ENABLE_RTT_SWAP =            0
                [49]    WR_CTR_ENABLE_RTT_SWAP =        0
                [48]    WR_CTR_VREF_COUNTER_RESET_VAL = 150ns converted to clock cycles (depends on the frequency)  // JESD79-4C Table 67

        rc::reset
          IOM0.DDRPHY_RC_CONFIG0_P0               // 0x8000C8000701103F
                [all]   0
                [48-51] GLOBAL_PHY_OFFSET =
                            MSS_FREQ_EQ_1866: 12
                            MSS_FREQ_EQ_2133: 12
                            MSS_FREQ_EQ_2400: 13
                            MSS_FREQ_EQ_2666: 13
                [62]    PERFORM_RDCLK_ALIGN = 1

          IOM0.DDRPHY_RC_CONFIG1_P0               // 0x8000C8010701103F
                [all]   0

          IOM0.DDRPHY_RC_CONFIG2_P0               // 0x8000C8020701103F
                [all]   0
                [48-52] CONSEC_PASS = 8
                [57-58] 3                   // not documented, BURST_WINDOW?

          IOM0.DDRPHY_RC_CONFIG3_P0               // 0x8000C8070701103F
                [all]   0
                [51-54] COARSE_CAL_STEP_SIZE = 4  // 5/128

          IOM0.DDRPHY_RC_RDVREF_CONFIG0_P0 =      // 0x8000C8090701103F
                [all]   0
                [48-63] WAIT_TIME =
                            0xffff          // as slow as possible, or use calculation from vref_guess_time(), or:
                            MSS_FREQ_EQ_1866: 0x0804
                            MSS_FREQ_EQ_2133: 0x092a
                            MSS_FREQ_EQ_2400: 0x0a50
                            MSS_FREQ_EQ_2666: 0x0b74    // use this value for all freqs maybe?

          IOM0.DDRPHY_RC_RDVREF_CONFIG1_P0 =      // 0x8000C80A0701103F
                [all]   0
                [48-55] CMD_PRECEDE_TIME =  (AL + CL + 15)
                [56-59] MPR_LOCATION =      4     // From R. King. The only other possible value is 8

        seq::reset
          IOM0.DDRPHY_SEQ_CONFIG0_P0 =            // 0x8000C4020701103F
                [all]   0
                [49]    TWO_CYCLE_ADDR_EN =
                            2N mode:                1
                            else:                   0
                [54]    DELAYED_PAR = 1
                [62]    PAR_A17_MASK =
                            16Gb x4 configuration:  0
                            else:                   1

          // All log2 values in timing registers are rounded up (I think...)
          IOM0.DDRPHY_SEQ_MEM_TIMING_PARAM0_P0 =  // 0x8000C4120701103F
                [all]   0
                [48-51] TMOD_CYCLES = 5           // log2(max(tMRD, tMOD)) = log2(24), JEDEC tables 169 and 170 and section 13.5
                [52-55] TRCD_CYCLES = log2(tRCD)  // 12.5-15ns, depending on freq either 4 or 5, JEDEC tables 144-150 and s. 13.5
                [56-59] TRP_CYCLES =  log2(tRP)   // 12.5-15ns, depending on freq either 4 or 5, JEDEC tables 144-150 and s. 13.5
                [52-55] TRFC_CYCLES = log2(tRFC)  // different DIMMs on one port may have different tRFCs, use max?

          IOM0.DDRPHY_SEQ_MEM_TIMING_PARAM1_P0 =  // 0x8000C4130701103F
                [all]   0
                [48-51] TZQINIT_CYCLES =  10      // log2(1024), JEDEC tables 169 and 170
                [52-55] TZQCS_CYCLES =    7       // log2(128), JEDEC tables 169 and 170
                [56-59] TWLDQSEN_CYCLES = 5       // log2(25) rounded up, JEDEC tables 169 and 170
                [60-63] TWRMRD_CYCLES =   6       // log2(40) rounded up, JEDEC tables 169 and 170

          IOM0.DDRPHY_SEQ_MEM_TIMING_PARAM2_P0 =  // 0x8000C4140701103F
                [all]   0
                [48-51] TODTLON_OFF_CYCLES =  log2(CWL + AL + PL - 2)
                [52-63] =                     0x777     // "Reset value of SEQ_TIMING2 is lucky 7's"

          IOM0.DDRPHY_SEQ_RD_WR_DATA0_P0 =        // 0x8000C4000701103F
                [all]   0
                [48-63] RD_RW_DATA_REG0 = 0xaa00

          IOM0.DDRPHY_SEQ_RD_WR_DATA1_P0 =        // 0x8000C4010701103F
                [all]   0
                [48-63] RD_RW_DATA_REG1 = 0x00aa

          IOM0.DDRPHY_SEQ_ODT_RD_CONFIG0_P0 =     // 0x8000C40E0701103F
                F(X) = (((X >> 4) & 0xc) | ((X >> 2) & 0x3))    // Bits 0,1,4,5 of X, see also MC01.PORT0.SRQ.MBA_FARB2Q
                [all]   0
                [48-51] ODT_RD_VALUES0 = F(ATTR_MSS_VPD_MT_ODT_RD[index(MCA)][0][0])
                [56-59] ODT_RD_VALUES1 = F(ATTR_MSS_VPD_MT_ODT_RD[index(MCA)][0][1])

          IOM0.DDRPHY_SEQ_ODT_RD_CONFIG1_P0 =     // 0x8000C40F0701103F
                F(X) = (((X >> 4) & 0xc) | ((X >> 2) & 0x3))    // Bits 0,1,4,5 of X, see also MC01.PORT0.SRQ.MBA_FARB2Q
                [all]   0
                [48-51] ODT_RD_VALUES0 =    // TODO: where those VPD values come from? Aren't they the same by any chance?
                          count_dimm(MCA) == 2: F(ATTR_MSS_VPD_MT_ODT_RD[index(MCA)][1][0])
                          count_dimm(MCA) != 2: F(ATTR_MSS_VPD_MT_ODT_RD[index(MCA)][0][2])
                [56-59] ODT_RD_VALUES1 =
                          count_dimm(MCA) == 2: F(ATTR_MSS_VPD_MT_ODT_RD[index(MCA)][1][1])
                          count_dimm(MCA) != 2: F(ATTR_MSS_VPD_MT_ODT_RD[index(MCA)][0][3])


          IOM0.DDRPHY_SEQ_ODT_WR_CONFIG0_P0 =     // 0x8000C40A0701103F
                F(X) = (((X >> 4) & 0xc) | ((X >> 2) & 0x3))    // Bits 0,1,4,5 of X, see also MC01.PORT0.SRQ.MBA_FARB2Q
                [all]   0
                [48-51] ODT_WR_VALUES0 = F(ATTR_MSS_VPD_MT_ODT_WR[index(MCA)][0][0])
                [56-59] ODT_WR_VALUES1 = F(ATTR_MSS_VPD_MT_ODT_WR[index(MCA)][0][1])

          IOM0.DDRPHY_SEQ_ODT_WR_CONFIG1_P0 =     // 0x8000C40B0701103F
                F(X) = (((X >> 4) & 0xc) | ((X >> 2) & 0x3))    // Bits 0,1,4,5 of X, see also MC01.PORT0.SRQ.MBA_FARB2Q
                [all]   0
                [48-51] ODT_WR_VALUES0 =    // TODO: where those VPD values come from? Aren't they the same by any chance?
                          count_dimm(MCA) == 2: F(ATTR_MSS_VPD_MT_ODT_WR[index(MCA)][1][0])
                          count_dimm(MCA) != 2: F(ATTR_MSS_VPD_MT_ODT_WR[index(MCA)][0][2])
                [56-59] ODT_WR_VALUES1 =
                          count_dimm(MCA) == 2: F(ATTR_MSS_VPD_MT_ODT_WR[index(MCA)][1][1])
                          count_dimm(MCA) != 2: F(ATTR_MSS_VPD_MT_ODT_WR[index(MCA)][0][3])

        reset_ac_boost_cntl
          IOM0.DDRPHY_DP16_ACBOOST_CTL_BYTE{0,1}_P0_{0,1,2,3,4} =     // 0x8000002{2,3}0701103F, +0x0400_0000_0000
                // For all of the AC Boost attributes, they're laid out in the uint32_t as such:
                // Bit 0-2   = DP16 Block 0 (DQ Bits 0-7)       BYTE0_P0_0
                // Bit 3-5   = DP16 Block 0 (DQ Bits 8-15)      BYTE1_P0_0
                // Bit 6-8   = DP16 Block 1 (DQ Bits 0-7)       BYTE0_P0_1
                // Bit 9-11  = DP16 Block 1 (DQ Bits 8-15)      BYTE1_P0_1
                // Bit 12-14 = DP16 Block 2 (DQ Bits 0-7)       BYTE0_P0_2
                // Bit 15-17 = DP16 Block 2 (DQ Bits 8-15)      BYTE1_P0_2
                // Bit 18-20 = DP16 Block 3 (DQ Bits 0-7)       BYTE0_P0_3
                // Bit 21-23 = DP16 Block 3 (DQ Bits 8-15)      BYTE1_P0_3
                // Bit 24-26 = DP16 Block 4 (DQ Bits 0-7)       BYTE0_P0_4
                // Bit 27-29 = DP16 Block 4 (DQ Bits 8-15)      BYTE1_P0_4
                [all]   0?    // function does read prev values from SCOM but then overwrites all non-const-0 fields. Why bother?
                [48-50] S{0,1}ACENSLICENDRV_DC = appropriate bits from ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_DOWN
                [51-53] S{0,1}ACENSLICENDRV_DC = appropriate bits from ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_UP
                [54-56] S{0,1}ACENSLICENDRV_DC = appropriate bits from ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_RD_UP

        reset_ctle_cntl
          IOM0.DDRPHY_DP16_CTLE_CTL_BYTE{0,1}_P0_{0,1,2,3,4} =        // 0x8000002{0,1}0701103F, +0x0400_0000_0000
                // For the capacitance CTLE attributes, they're laid out in the uint64_t as such. The resitance
                // attributes are the same, but 3 bits long. Notice that DP Block X Nibble 0 is DQ0:3,
                // Nibble 1 is DQ4:7, Nibble 2 is DQ8:11 and 3 is DQ12:15.
                // Bit 0-1   = DP16 Block 0 Nibble 0     Bit 16-17 = DP16 Block 2 Nibble 0     Bit 32-33 = DP16 Block 4 Nibble 0
                // Bit 2-3   = DP16 Block 0 Nibble 1     Bit 18-19 = DP16 Block 2 Nibble 1     Bit 34-35 = DP16 Block 4 Nibble 1
                // Bit 4-5   = DP16 Block 0 Nibble 2     Bit 20-21 = DP16 Block 2 Nibble 2     Bit 36-37 = DP16 Block 4 Nibble 2
                // Bit 6-7   = DP16 Block 0 Nibble 3     Bit 22-23 = DP16 Block 2 Nibble 3     Bit 38-39 = DP16 Block 4 Nibble 3
                // Bit 8-9   = DP16 Block 1 Nibble 0     Bit 24-25 = DP16 Block 3 Nibble 0
                // Bit 10-11 = DP16 Block 1 Nibble 1     Bit 26-27 = DP16 Block 3 Nibble 1
                // Bit 12-13 = DP16 Block 1 Nibble 2     Bit 28-29 = DP16 Block 3 Nibble 2
                // Bit 14-15 = DP16 Block 1 Nibble 3     Bit 30-31 = DP16 Block 3 Nibble 3
                [48-49] NIB_{0,2}_DQSEL_CAP = appropriate bits from ATTR_MSS_VPD_MT_MC_DQ_CTLE_CAP
                [53-55] NIB_{0,2}_DQSEL_RES = appropriate bits from ATTR_MSS_VPD_MT_MC_DQ_CTLE_RES
                [56-57] NIB_{1,3}_DQSEL_CAP = appropriate bits from ATTR_MSS_VPD_MT_MC_DQ_CTLE_CAP
                [61-63] NIB_{1,3}_DQSEL_RES = appropriate bits from ATTR_MSS_VPD_MT_MC_DQ_CTLE_RES

        reset_delay
          // "If the reset value is not sufficient for the given system, these registers must be set via the programming interface."
          IOM0.DDRPHY_ADR_DELAY0_P0_ADR0 =
                [all]   0
                [49-55] ADR_DELAY0 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN0
                [57-63] ADR_DELAY1 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14
          IOM0.DDRPHY_ADR_DELAY1_P0_ADR0 =
                [all]   0
                [49-55] ADR_DELAY2 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT1
                [57-63] ADR_DELAY3 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C0
          IOM0.DDRPHY_ADR_DELAY2_P0_ADR0 =
                [all]   0
                [49-55] ADR_DELAY4 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA1
                [57-63] ADR_DELAY5 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A10
          IOM0.DDRPHY_ADR_DELAY3_P0_ADR0 =
                [all]   0
                [49-55] ADR_DELAY6 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT1
                [57-63] ADR_DELAY7 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA0
          IOM0.DDRPHY_ADR_DELAY4_P0_ADR0 =
                [all]   0
                [49-55] ADR_DELAY8 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A00
                [57-63] ADR_DELAY9 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT0
          IOM0.DDRPHY_ADR_DELAY5_P0_ADR0 =
                [all]   0
                [49-55] ADR_DELAY10 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT0
                [57-63] ADR_DELAY11 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15

          IOM0.DDRPHY_ADR_DELAY0_P0_ADR1 =
                [all]   0
                [49-55] ADR_DELAY0 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A13
                [57-63] ADR_DELAY1 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN1
          IOM0.DDRPHY_ADR_DELAY1_P0_ADR1 =
                [all]   0
                [49-55] ADR_DELAY2 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKN
                [57-63] ADR_DELAY3 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKP
          IOM0.DDRPHY_ADR_DELAY2_P0_ADR1 =
                [all]   0
                [49-55] ADR_DELAY4 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A17
                [57-63] ADR_DELAY5 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C1
          IOM0.DDRPHY_ADR_DELAY3_P0_ADR1 =
                [all]   0
                [49-55] ADR_DELAY6 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKN
                [57-63] ADR_DELAY7 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKP
          IOM0.DDRPHY_ADR_DELAY4_P0_ADR1 =
                [all]   0
                [49-55] ADR_DELAY8 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C2
                [57-63] ADR_DELAY9 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN1
          IOM0.DDRPHY_ADR_DELAY5_P0_ADR1 =
                [all]   0
                [49-55] ADR_DELAY10 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A02
                [57-63] ADR_DELAY11 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_PAR

          IOM0.DDRPHY_ADR_DELAY0_P0_ADR2 =
                [all]   0
                [49-55] ADR_DELAY0 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN0
                [57-63] ADR_DELAY1 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16
          IOM0.DDRPHY_ADR_DELAY1_P0_ADR2 =
                [all]   0
                [49-55] ADR_DELAY2 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A08
                [57-63] ADR_DELAY3 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A05
          IOM0.DDRPHY_ADR_DELAY2_P0_ADR2 =
                [all]   0
                [49-55] ADR_DELAY4 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A03
                [57-63] ADR_DELAY5 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A01
          IOM0.DDRPHY_ADR_DELAY3_P0_ADR2 =
                [all]   0
                [49-55] ADR_DELAY6 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A04
                [57-63] ADR_DELAY7 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A07
          IOM0.DDRPHY_ADR_DELAY4_P0_ADR2 =
                [all]   0
                [49-55] ADR_DELAY8 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A09
                [57-63] ADR_DELAY9 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A06
          IOM0.DDRPHY_ADR_DELAY5_P0_ADR2 =
                [all]   0
                [49-55] ADR_DELAY10 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE1
                [57-63] ADR_DELAY11 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A12

          IOM0.DDRPHY_ADR_DELAY0_P0_ADR3 =
                [all]   0
                [49-55] ADR_DELAY0 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ACTN
                [57-63] ADR_DELAY1 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A11
          IOM0.DDRPHY_ADR_DELAY1_P0_ADR3 =
                [all]   0
                [49-55] ADR_DELAY2 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG0
                [57-63] ADR_DELAY3 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE0
          IOM0.DDRPHY_ADR_DELAY2_P0_ADR3 =
                [all]   0
                [49-55] ADR_DELAY4 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE1
                [57-63] ADR_DELAY5 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG1
          IOM0.DDRPHY_ADR_DELAY3_P0_ADR3 =
                [all]   0
                [49-55] ADR_DELAY6 = ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE0

        reset_tsys_adr
          IOM0.DDRPHY_ADR_MCCLK_WRCLK_PR_STATIC_OFFSET_P0_ADR32S{0,1} =   // 0x800080330701103F, +0x0400_0000_0000
                [all]   0
                [49-55] TSYS_WRCLK = ATTR_MSS_VPD_MR_TSYS_ADR
                      // From regs spec:
                      // Set to â€˜19â€™h for 2666 MT/s.
                      // Set to â€˜17â€™h for 2400 MT/s.
                      // Set to â€˜14â€™h for 2133 MT/s.
                      // Set to â€˜12â€™h for 1866 MT/s.

        reset_tsys_data
          IOM0.DDRPHY_DP16_WRCLK_PR_P0_{0,1,2,3,4} =                      // 0x800000740701103F, +0x0400_0000_0000
                [all]   0
                [49-55] TSYS_WRCLK = ATTR_MSS_VPD_MR_TSYS_DATA
                      // From regs spec:
                      // Set to â€˜12â€™h for 2666 MT/s.
                      // Set to â€˜10â€™h for 2400 MT/s.
                      // Set to â€˜0Fâ€™h for 2133 MT/s.
                      // Set to â€˜0Dâ€™h for 1866 MT/s.

        reset_io_impedances
          IOM0.DDRPHY_DP16_IO_TX_FET_SLICE_P0_{0,1,2,3,4} =               // 0x800000780701103F, +0x0400_0000_0000
                [all]   0
                // 0 - Hi-Z, otherwise impedance = 240/<num of set bits> Ohms
                [49-55] EN_SLICE_N_WR = ATTR_MSS_VPD_MT_MC_DRV_IMP_DQ_DQS[{0,1,2,3,4}]
                [57-63] EN_SLICE_P_WR = ATTR_MSS_VPD_MT_MC_DRV_IMP_DQ_DQS[{0,1,2,3,4}]

          IOM0.DDRPHY_DP16_IO_TX_PFET_TERM_P0_{0,1,2,3,4} =               // 0x8000007B0701103F, +0x0400_0000_0000
                [all]   0
                // 0 - Hi-Z, otherwise impedance = 240/<num of set bits> Ohms
                [49-55] EN_SLICE_N_WR = ATTR_MSS_VPD_MT_MC_RCV_IMP_DQ_DQS[{0,1,2,3,4}]

          IOM0.DDRPHY_ADR_IO_FET_SLICE_EN_MAP0_P0_ADR1 =    // yes, ADR1  // 0x800044200701103F
                // These are RMW one at a time. I don't see why not all at once, or at least in pairs (P and N of the same clocks)
                if (ATTR_MSS_VPD_MT_MC_DRV_IMP_CLK == ENUM_ATTR_MSS_VPD_MT_MC_DRV_IMP_CLK_OHM30):
                  [54,52,62,60] SLICE_SELn = 1    // CLK00 P, CLK00 N, CLK01 P, CLK01 N
                else
                  [54,52,62,60] = 0

          // Following are reordered to minimalize number of register reads/writes
          ------------------------------------------------------------------------
          val = (ATTR_MSS_VPD_MT_MC_DRV_IMP_CMD_ADDR == ENUM_ATTR_MSS_VPD_MT_MC_DRV_IMP_CMD_ADDR_OHM30) ? 1 : 0
          IOM0.DDRPHY_ADR_IO_FET_SLICE_EN_MAP0_P0_ADR0 =
                [50,56,58,62] =           val       // ADDR14/WEN, BA1, ADDR10, BA0
          IOM0.DDRPHY_ADR_IO_FET_SLICE_EN_MAP1_P0_ADR0 =
                [48,54] =                 val       // ADDR0, ADDR15/CAS
          IOM0.DDRPHY_ADR_IO_FET_SLICE_EN_MAP0_P0_ADR1 =        // same as CLK, however it uses different VPD
                [48,56] =                 val       // ADDR13, ADDR17/RAS
          IOM0.DDRPHY_ADR_IO_FET_SLICE_EN_MAP1_P0_ADR1 =
                [52]    =                 val       // ADDR2
          IOM0.DDRPHY_ADR_IO_FET_SLICE_EN_MAP0_P0_ADR2 =
                [50,52,54,56,58,60,62] =  val       // ADDR16/RAS, ADDR8, ADDR5, ADDR3, ADDR1, ADDR4, ADDR7
          IOM0.DDRPHY_ADR_IO_FET_SLICE_EN_MAP1_P0_ADR2 =
                [48,50,54] =              val       // ADDR9, ADDR6, ADDR12
          IOM0.DDRPHY_ADR_IO_FET_SLICE_EN_MAP0_P0_ADR3 =
                [48,50,52,58] =           val       // ACT_N, ADDR11, BG0, BG1

          // Following are reordered to minimalize number of register reads/writes
          ------------------------------------------------------------------------
          val = (ATTR_MSS_VPD_MT_MC_DRV_IMP_CNTL == ENUM_ATTR_MSS_VPD_MT_MC_DRV_IMP_CNTL_OHM30) ? 1 : 0
          IOM0.DDRPHY_ADR_IO_FET_SLICE_EN_MAP0_P0_ADR0 =        // same as CMD/ADDR, however it uses different VPD
                [52,60] =                 val       // ODT3, ODT1
          IOM0.DDRPHY_ADR_IO_FET_SLICE_EN_MAP1_P0_ADR0 =        // same as CMD/ADDR, however it uses different VPD
                [50,52] =                 val       // ODT2, ODT0
          IOM0.DDRPHY_ADR_IO_FET_SLICE_EN_MAP1_P0_ADR1 =        // same as CMD/ADDR, however it uses different VPD
                [54] =                    val       // PARITY
          IOM0.DDRPHY_ADR_IO_FET_SLICE_EN_MAP1_P0_ADR2 =        // same as CMD/ADDR, however it uses different VPD
                [52] =                    val       // CKE1
          IOM0.DDRPHY_ADR_IO_FET_SLICE_EN_MAP0_P0_ADR3 =        // same as CMD/ADDR, however it uses different VPD
                [54,56,60,62] =           val       // CKE0, CKE3, CKE2, RESET_N

          // Following are reordered to minimalize number of register reads/writes
          ------------------------------------------------------------------------
          val = (ATTR_MSS_VPD_MT_MC_DRV_IMP_CSCID == ENUM_ATTR_MSS_VPD_MT_MC_DRV_IMP_CSCID_OHM30) ? 1 : 0
          IOM0.DDRPHY_ADR_IO_FET_SLICE_EN_MAP0_P0_ADR0 =        // same as CMD/ADDR and CNTL, however it uses different VPD
                [48,54] =                 val       // CS0, CID0
          IOM0.DDRPHY_ADR_IO_FET_SLICE_EN_MAP0_P0_ADR1 =        // same as CLK and CMD/ADDR, however it uses different VPD
                [50,58] =                 val       // CS1, CID1
          IOM0.DDRPHY_ADR_IO_FET_SLICE_EN_MAP1_P0_ADR1 =        // same as CMD/ADDR and CNTL, however it uses different VPD
                [48,50] =                 val       // CS3, CID2
          IOM0.DDRPHY_ADR_IO_FET_SLICE_EN_MAP0_P0_ADR2 =        // same as CMD/ADDR, however it uses different VPD
                [48] =                    val       // CS2

          // IO impedances regs summary:            lanes 9-15 have different possible settings (results in 15/30 vs 40/30 Ohm)
          // MAP0_ADR0: all set                       MAP1_ADR0: lanes 12-15 not set
          // MAP0_ADR1: all set                       MAP1_ADR1: lanes 12-15 not set
          // MAP0_ADR2: all set                       MAP1_ADR2: lanes 12-15 not set
          // MAP0_ADR3: all set                       MAP1_ADR3: not used
          // This mapping is consistent with ADR_DELAYx_P0_ADRy settings

        reset_wr_vref_registers
          IOM0.DDRPHY_DP16_WR_VREF_CONFIG0_P0_{0,1,2,3,4} =       // 0x8000006C0701103F, +0x0400_0000_0000
                // This may be a good place for tweaking training times, if needed
                [all]   0
                [48]    WR_CTR_1D_MODE_SWITCH =       0     // 1 for <DD2
                [49]    WR_CTR_RUN_FULL_1D =          1
                [50-52] WR_CTR_2D_SMALL_STEP_VAL =    0     // implicit +1
                [53-56] WR_CTR_2D_BIG_STEP_VAL =      1     // implicit +1
                [57-59] WR_CTR_NUM_BITS_TO_SKIP =     0     // skip all 7 (3 for x4) intermediary bits
                [60-62] WR_CTR_NUM_NO_INC_VREF_COMP = 7

          IOM0.DDRPHY_DP16_WR_VREF_CONFIG1_P0_{0,1,2,3,4} =       // 0x800000EC0701103F, +0x0400_0000_0000
                [all]   0
                [48]    WR_CTR_VREF_RANGE_SELECT =      0       // range 1 by default (60-92.5%)
                [49-55] WR_CTR_VREF_RANGE_CROSSOVER =   0x18    // JEDEC table 34
                [56-62] WR_CTR_VREF_SINGLE_RANGE_MAX =  0x32    // JEDEC table 34

          IOM0.DDRPHY_DP16_WR_VREF_STATUS0_P0_{0,1,2,3,4} =       // 0x8000002E0701103F, +0x0400_0000_0000
                [all]   0

          IOM0.DDRPHY_DP16_WR_VREF_STATUS1_P0_{0,1,2,3,4} =       // 0x8000002F0701103F, +0x0400_0000_0000
                [all]   0

          IOM0.DDRPHY_DP16_WR_VREF_ERROR_MASK{0,1}_P0_{0,1,2,3,4} =   // 0x800000F{B,A}0701103F, +0x0400_0000_0000
                [all]   0
                [48-63] 0xffff

          IOM0.DDRPHY_DP16_WR_VREF_ERROR{0,1}_P0_{0,1,2,3,4} =    // 0x800000A{E,F}0701103F, +0x0400_0000_0000
                [all]   0

          // Assume RDIMM
          // Assume unpopulated DIMMs/ranks are not calibrated so their settings doesn't matter (more reg accesses, much simpler code)
          IOM0.DDRPHY_DP16_WR_VREF_VALUE{0,1}_RANK_PAIR0_P0_{0,1,2,3,4} =   // 0x8000005{E,F}0701103F, +0x0400_0000_0000
          IOM0.DDRPHY_DP16_WR_VREF_VALUE{0,1}_RANK_PAIR1_P0_{0,1,2,3,4} =   // 0x8000015{E,F}0701103F, +0x0400_0000_0000
          IOM0.DDRPHY_DP16_WR_VREF_VALUE{0,1}_RANK_PAIR2_P0_{0,1,2,3,4} =   // 0x8000025{E,F}0701103F, +0x0400_0000_0000
          IOM0.DDRPHY_DP16_WR_VREF_VALUE{0,1}_RANK_PAIR3_P0_{0,1,2,3,4} =   // 0x8000035{E,F}0701103F, +0x0400_0000_0000
                [all]   0
                [49]    WR_VREF_RANGE_DRAM{0,2} = ATTR_MSS_VPD_MT_VREF_DRAM_WR & 0x40
                [50-55] WR_VREF_VALUE_DRAM{0,2} = ATTR_MSS_VPD_MT_VREF_DRAM_WR & 0x3f
                [57]    WR_VREF_RANGE_DRAM{1,3} = ATTR_MSS_VPD_MT_VREF_DRAM_WR & 0x40
                [58-63] WR_VREF_VALUE_DRAM{1,3} = ATTR_MSS_VPD_MT_VREF_DRAM_WR & 0x3f

        reset_drift_limits
          IOM0.DDRPHY_DP16_DRIFT_LIMITS_P0_{0,1,2,3,4} =          // 0x8000000A0701103F, +0x0400_0000_0000
                [48-49] DD2_BLUE_EXTEND_RANGE = 1         // always ONE_TO_FOUR due to red waterfall workaround

        // Workarounds
        dqs_polarity        // Does not apply to DD2

        rd_dia_config5
          IOM0.DDRPHY_DP16_RD_DIA_CONFIG5_P0_{0,1,2,3,4} =        // 0x800000120701103F, +0x0400_0000_0000
                // "this isn't an EC feature workaround, it's a incorrect documentation workaround"
                [all]   0
                [49]    DYN_MCTERM_CNTL_EN =      1
                [52]    PER_CAL_UPDATE_DISABLE =  1     // "This bit must be set to 0 for normal operation"
                [59]    PERCAL_PWR_DIS =          1

        dqsclk_offset
          IOM0.DDRPHY_DP16_DQSCLK_OFFSET_P0_{0,1,2,3,4} =         // 0x800000370701103F, +0x0400_0000_0000
                // "this isn't an EC feature workaround, it's a incorrect documentation workaround"
                [all]   0
                [49-55] DQS_OFFSET = 0x08       // Config provided by S. Wyatt 9/13

        odt_config        // Does not apply to DD2

  - Do FIRry things
    mss::unmask::after_scominit(MCBIST)
      for each functional or magic MCA
        IOM0.IOM_PHY0_DDRPHY_FIR_REG =      // 0x07011000         // maybe use SCOM1 (AND) 0x07011001
              [56]  IOM_PHY0_DDRPHY_FIR_REG_DDR_FIR_ERROR_2 = 0   // calibration errors
              [58]  IOM_PHY0_DDRPHY_FIR_REG_DDR_FIR_ERROR_4 = 0   // DLL errors
        MC01.PORT0.SRQ.MBACALFIRQ =         // 0x07010900         // maybe use SCOM1 (AND) 0x07010901
              [4]   MBACALFIRQ_RCD_PARITY_ERROR = 0
              [8]   MBACALFIRQ_DDR_MBA_EVENT_N =  0

## mss_ddr_phy_reset: Soft reset of DDR PHY macros (13.9)

> - Lock DDR DLLs
>   - Already configured DDR DLL in scaninit
> - Sends Soft DDR Phy reset
> - Kick off internal ZQ Cal
> - Perform any config that wasn't scanned in (TBD)
>   - Nothing known here

for each functional MCBIST:
  p9_mss_ddr_phy_reset
    if (count_dimms(MCBIST) == 0) return

    for each functional or magic MCA
      MC01.PORT0.SRQ.MBA_FARB5Q =
            [8]     MBA_FARB5Q_CFG_FORCE_MCLK_LOW_N = 0

    // Drive all control signals to their inactive/idle state, or inactive value
    for each functional or magic MCA
      IOM0.DDRPHY_DP16_SYSCLK_PR0_P0_{0,1,2,3,4} =              // 0x800000070701103F, +0x0400_0000_0000
      IOM0.DDRPHY_DP16_SYSCLK_PR1_P0_{0,1,2,3,4} =              // 0x8000007F0701103F, +0x0400_0000_0000
            [all]   0
            [48]    reserved = 1            // MCA_DDRPHY_DP16_SYSCLK_PR0_P0_0_01_ENABLE

    // Assert reset to PHY for 32 memory clocks
    for each functional or magic MCA
      MC01.PORT0.SRQ.MBA_CAL0Q =                                // 0x0701090F
            [57]    MBA_CAL0Q_RESET_RECOVER = 1

    delay(32 memclocks)     // These delays probably are the only reason why everything has separate "for each MCA" loops

    // Deassert reset_n
    for each functional or magic MCA
      MC01.PORT0.SRQ.MBA_CAL0Q =                                // 0x0701090F
            [57]    MBA_CAL0Q_RESET_RECOVER = 0

    // Flush output drivers
    for each functional or magic MCA
      IOM0.DDRPHY_ADR_OUTPUT_FORCE_ATEST_CNTL_P0_ADR32S{0,1} =    // 0x800080350701103F, 0x800084350701103F
            [all]   0
            [48]    FLUSH =   1
            [50]    INIT_IO = 1

      IOM0.DDRPHY_DP16_CONFIG0_P0_{0,1,2,3,4} =                   // 0x800000030701103F, +0x0400_0000_0000
            [all]   0
            [51]    FLUSH =                 1
            [54]    INIT_IO =               1
            [55]    ADVANCE_PING_PONG =     1
            [58]    DELAY_PING_PONG_HALF =  1

    delay(32 memclocks)     // These delays probably are the only reason why everything has separate "for each MCA" loops

    for each functional or magic MCA
      IOM0.DDRPHY_ADR_OUTPUT_FORCE_ATEST_CNTL_P0_ADR32S{0,1} =    // 0x800080350701103F, 0x800084350701103F
            [all]   0
            [48]    FLUSH =   0
            [50]    INIT_IO = 0

      IOM0.DDRPHY_DP16_CONFIG0_P0_{0,1,2,3,4} =                   // 0x800000030701103F, +0x0400_0000_0000
            [all]   0
            [51]    FLUSH =                 0
            [54]    INIT_IO =               0
            [55]    ADVANCE_PING_PONG =     1
            [58]    DELAY_PING_PONG_HALF =  1

    // ZCTL Enable
    for each magic MCA            // note we are already in "for each MCBIST" loop
      IOM0.DDRPHY_PC_RESETS_P0 =                                  // 0x8000C00E0701103F
            // Yet another documentation error: all bits in this register are marked as read-only
            [51]    ENABLE_ZCAL = 1

    // Is this really necessary? We are polling ZCAL_DONE, if it were to fail we're screwed anyway
    delay(1024 memclocks)
    // Comment says ENABLE_ZCAL has to be deasserted here, neither code nor spec agrees
    for each magic MCA            // note we are already in "for each MCBIST" loop
      timeout(50*10ns):
            // Maybe this should be reordered for consistent timeouts across MCAs: timeout->for each->check bit.
            // Difference between RMW (assert reset bit) and polling should be much smaller that this timeout,
            // which would otherwise be added per each magic MCA in the worst case scenario. On the other hand,
            // number of magic MCAs is const and relatively small, we may end up dropping 'for each' altogether.
            if (IOM0.DDRPHY_PC_DLL_ZCAL_CAL_STATUS_P0 [63] /*ZCAL_DONE*/) == 1) break    // 0x8000C0000701103F
            delay(10ns)

    // DLL calibration
    // Here was an early return if no functional MCAs were found. Wouldn't that make whole MCBIST non-functional?
    for each functional MCA
      IOM0.DDRPHY_ADR_DLL_CNTL_P0_ADR32S{0,1} =           // 0x8000803A0701103F, 0x8000843A0701103F
            [48]    INIT_RXDLL_CAL_RESET = 0
      IOM0.DDRPHY_DP16_DLL_CNTL{0,1}_P0_{0,1,2,3} =       // 0x8000002{4,5}0701103F, +0x0400_0000_0000
      IOM0.DDRPHY_DP16_DLL_CNTL0_P0_4
            [48]    INIT_RXDLL_CAL_RESET = 0
      IOM0.DDRPHY_DP16_DLL_CNTL1_P0_4
            [48]    INIT_RXDLL_CAL_RESET = 1      // no-op?

    // 32,772 dphy_nclk cycles from Reset=0 to VREG Calibration to exhaust all values
    // 37,382 dphy_nclk cycles for full calibration to start and fail ("worst case")
    delay(37,382 memclocks)

    // The comment before poll says:
    // > To keep things simple, we'll poll for the change in one of the ports. Once that's completed, we'll
    // > check the others. If any one has failed, or isn't notifying complete, we'll pop out an error
    // The issue is that it only tests the first of the functional ports. Other ports may or may not have failed.
    // Even if this times out, the rest of the function continues normally, without throwing any error...
    // A case in which the first MCA finishes calib before the rest does is caught by "worst case" delay above.
    // If the tests below were done properly (poll every MCA), we could do better than "worst case", statistically
    // we should hit proper VREG in half of that period, which would give ~8ms wasted here (average for DDR4-2133).
    // For now I'll leave it described as it was done in Hostboot, but there is room for improvement here.
    timeout(50*10ns):
      if (IOM0.DDRPHY_PC_DLL_ZCAL_CAL_STATUS_P0
                [48]  DP_DLL_CAL_GOOD ==        1
                [49]  DP_DLL_CAL_ERROR ==       0
                [50]  DP_DLL_CAL_ERROR_FINE ==  0
                [51]  ADR_DLL_CAL_GOOD ==       1
                [52]  ADR_DLL_CAL_ERROR ==      0
                [53]  ADR_DLL_CAL_ERROR_FINE == 0) break    // success
      if (IOM0.DDRPHY_PC_DLL_ZCAL_CAL_STATUS_P0
                [49]  DP_DLL_CAL_ERROR ==       1 |
                [50]  DP_DLL_CAL_ERROR_FINE ==  1 |
                [52]  ADR_DLL_CAL_ERROR ==      1 |
                [53]  ADR_DLL_CAL_ERROR_FINE == 1) break and do the workaround
      // either 48 or 51 is 0
      delay(10ns)

    // Workaround is also required if any of coarse VREG has value 1 after calibration
    // Test from poll above is repeated here - this time for every MCA, but it doesn't wait until DLL gets
    // calibrated if that is still in progress. The registers below (also used in the workaround) __must not__
    // be written to while hardware calibration is in progress.
    for each functional MCA     // this loop may be skipped if we're doing workaround anyway
      if (IOM0.DDRPHY_ADR_DLL_VREG_COARSE_P0_ADR32S0        |       // 0x8000803E0701103F
          IOM0.DDRPHY_DP16_DLL_VREG_COARSE0_P0_{0,1,2,3,4}  |       // 0x8000002C0701103F, +0x0400_0000_0000
          IOM0.DDRPHY_DP16_DLL_VREG_COARSE1_P0_{0,1,2,3}    |       // 0x8000002D0701103F, +0x0400_0000_0000
                [56-62] REGS_RXDLL_VREG_DAC_COARSE = 1)    // The same offset for ADR and DP16, convenient
              do the workaround

    // Proper workaround - skip if not needed
    -----------------------------------------
    fix_bad_voltage_settings
      for each functional MCA
        // Each MCA has 10 DLLs: ADR DLL0, DP0-4 DLL0, DP0-3 DLL1. Each of those can fail. For each DLL there are 5 registers
        // used in this workaround, those are (see src/import/chips/p9/procedures/hwp/memory/lib/workarounds/dll_workaround.C):
        // - l_CNTRL:         DP16 or ADR CNTRL register
        // - l_COARSE_SAME:   VREG_COARSE register for same DLL as CNTRL reg
        // - l_COARSE_NEIGH:  VREG_COARSE register for DLL neighbor for this workaround
        // - l_DAC_LOWER:     DLL DAC Lower register
        // - l_DAC_UPPER:     DLL DAC Upper register
        // Warning: the last two have their descriptions swapped in dll_workaround.H
        // It seems that the code excepts that DLL neighbor is always good, what if it isn't?
        //
        // General flow, stripped from C++ bloating and repeated loops:
        for each DLL          // list in workarounds/dll_workaround.C
          1. check if this DLL failed, if not - skip to the next one
                (l_CNTRL[62 | 63] | l_COARSE_SAME[56-62] == 1) -> failed
          2. set reset bit, set skip VREG bit, clear the error bits
                l_CNTRL[48] =     1
                l_CNTRL[50-51] =  2     // REGS_RXDLL_CAL_SKIP, 2 - skip VREG calib., do coarse delay calib. only
                l_CNTRL[62-63] =  0
          3. clear DLL FIR (see "Do FIRry things" at the end of 13.8)  // this was actually done for non-failed DLLs too, why?
                IOM0.IOM_PHY0_DDRPHY_FIR_REG =      // 0x07011000         // maybe use SCOM1 (AND) 0x07011001
                      [56]  IOM_PHY0_DDRPHY_FIR_REG_DDR_FIR_ERROR_2 = 0   // calibration errors
                      [58]  IOM_PHY0_DDRPHY_FIR_REG_DDR_FIR_ERROR_4 = 0   // DLL errors
          4. write the VREG DAC value found in neighbor (good) to the failing DLL VREG DAC
                l_COARSE_SAME[56-62] = l_COARSE_NEIGH[56-62]
          5. reset the upper and lower fine calibration bits back to defaults
                l_DAC_LOWER[56-63] =  0x0x8000    // Hard coded default values per Steve Wyatt for this workaround
                l_DAC_UPPER[56-63] =  0x0xFFE0
          6. run DLL Calibration again on failed DLLs
                l_CNTRL[48] = 0
        // Wait for calibration to finish
        delay(37,382 memclocks)     // again, we could do better than this

        // Check if calibration succeeded (same tests as in 1 above, for all DLLs)
        for each DLL
          if (l_CNTRL[62 | 63] | l_COARSE_SAME[56-62] == 1): failed, assert and die?
    -----------------------------------------
    // End of DLL workaround

    // Start bang-bang-lock
    // Take dphy_nclk/SysClk alignment circuits out of reset and put into continuous update mode
    for each functional MCA
      IOM0.DDRPHY_ADR_SYSCLK_CNTL_PR_P0_ADR32S{0,1} =           // 0x800080320701103F, +0x0400_0000_0000
      IOM0.DDRPHY_DP16_SYSCLK_PR0_P0_{0,1,2,3,4} =              // 0x800000070701103F, +0x0400_0000_0000
      IOM0.DDRPHY_DP16_SYSCLK_PR1_P0_{0,1,2,3} =                // 0x8000007F0701103F, +0x0400_0000_0000
            [all]   0
            [48-63] 0x8024      // From the DDR PHY workbook

    // Wait at least 5932 dphy_nclk clock cycles to allow the dphy_nclk/SysClk alignment circuit to perform initial alignment
    delay(5932 memclocks)

    // Check for LOCK in DDRPHY_DP16_SYSCLK_PR_VALUE registers and DDRPHY_ADR_SYSCLK_PR_VALUE
    for each functional MCA
      timeout(50*10ns):
        IOM0.DDRPHY_ADR_SYSCLK_PR_VALUE_RO_P0_ADR32S{0,1}       // 0x800080340701103F, +0x0400_0000_0000
              [56]  BB_LOCK     &
        IOM0.DDRPHY_DP16_SYSCLK_PR_VALUE_P0_{0,1,2,3}           // 0x800000730701103F, +0x0400_0000_0000
              [48]  BB_LOCK0    &
              [56]  BB_LOCK1    &
        IOM0.DDRPHY_DP16_SYSCLK_PR_VALUE_P0_4
              [48]  BB_LOCK0          // last DP16 uses only first half
        if all bits listed above are set: break
        delay(10ns)

    // Write 0b0 into the DDRPHY_PC_RESETS register bit 1. This write de-asserts the SYSCLK_RESET
    for each functional MCA
      IOM0.DDRPHY_PC_RESETS_P0 =                                  // 0x8000C00E0701103F
              [49]  SYSCLK_RESET = 0

    // Reset the windage registers
    // According to the PHY team, resetting the read delay offset must be done after SYSCLK_RESET
    for each functional MCA
      // This was using floating point math, so it has to be changed.
      // ATTR_MSS_VPD_MT_WINDAGE_RD_CTR holds (signed) value of offset in picoseconds. It must be converted to
      // phase rotator ticks. There are 128 ticks per clock, and clock period depends on memory frequency.
      // See FREQ_TO_CLOCK_PERIOD in /src/import/generic/memory/lib/utils/conversion.H for values.
      // Result is rounded away from zero, so we have to add *or subtract* half of tick.
      //
      // Maybe we can skip this (40 register writes per port), from documentation:
      // "This register must not be set to a nonzero value unless detailed timing analysis shows that, for
      // a particular configuration, the read-centering algorithm places the sampling point off from the eye center."
      IOM0.DDRPHY_DP16_READ_DELAY_OFFSET0_RANK_PAIR{0,1,2,3}_P0_{0,1,2,3,4} =   // 0x80000{0,1,2,3}0C0701103F, +0x0400_0000_0000
      IOM0.DDRPHY_DP16_READ_DELAY_OFFSET1_RANK_PAIR{0,1,2,3}_P0_{0,1,2,3,4} =   // 0x80000{0,1,2,3}0D0701103F, +0x0400_0000_0000
              [all]   0
              [49-55] OFFSET0 = offset_in_ticks_rounded
              [57-63] OFFSET1 = offset_in_ticks_rounded

    // Take the dphy_nclk/SysClk alignment circuit out of the Continuous Update mode
    for each functional MCA
      IOM0.DDRPHY_ADR_SYSCLK_CNTL_PR_P0_ADR32S{0,1} =           // 0x800080320701103F, +0x0400_0000_0000
      IOM0.DDRPHY_DP16_SYSCLK_PR0_P0_{0,1,2,3,4} =              // 0x800000070701103F, +0x0400_0000_0000
      IOM0.DDRPHY_DP16_SYSCLK_PR1_P0_{0,1,2,3} =                // 0x8000007F0701103F, +0x0400_0000_0000
            [all]   0
            [48-63] 0x8020      // From the DDR PHY workbook

    // Wait at least 32 dphy_nclk clock cycles
    delay(32 memclocks)
    // Done bang-bang-lock

    // Per J. Bialas, force_mclk_low can be dasserted
    for each functional MCA
      MC01.PORT0.SRQ.MBA_FARB5Q =
            [8]     MBA_FARB5Q_CFG_FORCE_MCLK_LOW_N = 1

    // Workarounds
    // It reads and writes back DDRPHY_DP16_RD_VREF_DAC_n_P0_p. Docs don't say it has side effects, but who knows...
    mss::workarounds::dp16::after_phy_reset - not needed on DD2

    // New for Nimbus - perform duty cycle clock distortion calibration (DCD cal)
    // Per PHY team's characterization, the DCD cal needs to be run after DLL calibration
    // It can be skipped based on ATTR_MSS_RUN_DCD_CALIBRATION
    for each functional MCA
      // DCD hardware calibration is a three step process:
      // 1) kick off cal on all the registers
      // 2) poll for done on all of the registers
      // 3) loop through the list of failing DCD regs and do the software calibration
      // Step 2) in hostboot also calculates average value of adjust for all successfully calibrated regs. This value
      // is later discarded in step 3), so instead of doing these steps separately we can modify and merge them into
      // one loop. Note that software calibration takes time, it may impact the timeout calculation for further regs.
      //
      // 1) kick off cal on all the registers
      IOM0.DDRPHY_ADR_DCD_CONTROL_P0_ADR32S0                        // 0x800080380701103F
      IOM0.DDRPHY_DP16_DCD_CONTROL{0,1}_P0_{0,1,2,3}                // 0x800000A{4,5}0701103F, +0x0400_0000_0000
      IOM0.DDRPHY_DP16_DCD_CONTROL0_P0_4
              [all]   0
              [48-63] 0x80a0  // for DD2 first field (DLL_DCD_ADJUST) is 8b long, for DD1 it was 7b

      // 2) poll for done on all of the registers
      IOM0.DDRPHY_ADR_DCD_CONTROL_P0_ADR32S0                        // 0x800080380701103F
      IOM0.DDRPHY_DP16_DCD_CONTROL{0,1}_P0_{0,1,2,3}                // 0x800000A{4,5}0701103F, +0x0400_0000_0000
      IOM0.DDRPHY_DP16_DCD_CONTROL0_P0_4
        // Timeout is separate for each reg, but perhaps it should use one global number of iterations for all regs per MCA
        timeout((128 + 256) * 100ns):         // starting from the middle, max 128 steps down and 256 steps up
          if [61] DLL_DCD_CAL_DONE == 1: break
          delay(100ns)

        // 3) do the software calibration for failing DCD regs
        if [62] DLL_DCD_CAL_ERROR == 1:
          seed = 0x80
          A_val = B_val = 0
          // This is almost identical for both sides, might be a function
          // Can we use bisect instead of linear search? Would delays be different?
          // Hostboot returned RC which tells if given side failed, but it can fail only if SCOM access or delay
          // fails (in that case we have bigger problems...), otherwise it asserts.
          ------------------------------
          tick =      +1
          expected =  1
          overflow =  0xff
          [all]   0
          [48-55] DLL_DCD_ADJUST =      seed
          [56]    DLL_DCD_CORRECT_EN =  1
          [57]    DLL_DCD_ITER_A =      1   // side A
          [58]    DLL_DCD_CAL_ENABLE =  0
          [63]    DLL_DCD_COMPARE_OUT = 0
          // BUG? No delay between write and read here, but there is 100ns delay later
          write and read back register    // DLL_DCD_COMPARE_OUT will be set based on whether target val is higher/lower than seed
          if ([63] == 1):   // target is below seed value
            tick =      -1
            expected =  0
            overflow =  0x00
          // overflow is the last valid value (poor variable naming), so use do..while
          do:
            if ([63] == expected): break
            seed += tick
            [48-55] seed
            [63]    0     // must be cleared before each write
            write
            delay(100ns)
            read
            // Here was another 100ns delay. Docs does not specify any. Why delay *after* read?
            // Here current value was obtained from read value, but it should be always seed (unless HW modifies it?)
          while (seed != overflow)
          // BUG? Hostboot asserts on seed != overflow, what if it is the last good value? Let's check expected instead
          assert([63] == expected)  // maybe not assert? We didn't get 50% duty cycle, but it still might be close enough,
                                    // RDIMM is more forgiving than DIMM (40% instead of 48% min)
          A_val = seed
          ------------------------------
          // Note we use A value as a seed - in ideal world A_val == B_val, real world should be close to that
          // Hostboot used (A_val - 1) to cover corner case when A_val == B_val, but it introduced another corner case
          // for (A_val - 1) == B_val.
          do the same for side B
          // [57] = 0
          // B_val = seed
          ------------------------------
          // The final value is the average of the a-side and b-side values
          // Hostboot uses convoluted way of calculating target value based on RCs from functions above
          [48-55] (A_val + B_val) / 2
          [63]    0

    // FIR
    mss::check::during_phy_reset
      // Mostly FFDC, which to my current knowledge is just the error logging. If it does anything else,
      // this needs rechecking
      for each functional or magic MCA
        // If any of these bits is set, return error. Clear them unconditionally (maybe they are not cleared on platform reset?)
        MC01.PORT0.SRQ.MBACALFIRQ =           // 0x07010900         // use SCOM1 (AND) 0x07010901 for clearing
              [0]   MBACALFIRQ_MBA_RECOVERABLE_ERROR
              [1]   MBACALFIRQ_MBA_NONRECOVERABLE_ERROR
              [10]  MBACALFIRQ_SM_1HOT_ERR
        IOM0.IOM_PHY0_DDRPHY_FIR_REG          // 0x07011000         // use SCOM1 (AND) 0x07011001 for clearing
              [54]  IOM_PHY0_DDRPHY_FIR_REG_DDR_FIR_ERROR_0
              [55]  IOM_PHY0_DDRPHY_FIR_REG_DDR_FIR_ERROR_1
              [56]  IOM_PHY0_DDRPHY_FIR_REG_DDR_FIR_ERROR_2
              [57]  IOM_PHY0_DDRPHY_FIR_REG_DDR_FIR_ERROR_3
              [58]  IOM_PHY0_DDRPHY_FIR_REG_DDR_FIR_ERROR_4
              [59]  IOM_PHY0_DDRPHY_FIR_REG_DDR_FIR_ERROR_5
              [60]  IOM_PHY0_DDRPHY_FIR_REG_DDR_FIR_ERROR_6
              [61]  IOM_PHY0_DDRPHY_FIR_REG_DDR_FIR_ERROR_7

    mss::unmask::after_phy_reset
      // *MASK must be always written as a last one, otherwise we may get unintended actions
      MC01.MCBIST.MBA_SCOMFIR.MCBISTFIRACT0             // 0x07012306
            [2]   MCBISTFIRQ_INTERNAL_FSM_ERROR =       0
            [13]  MCBISTFIRQ_SCOM_RECOVERABLE_REG_PE =  0
            [14]  MCBISTFIRQ_SCOM_FATAL_REG_PE =        0
      MC01.MCBIST.MBA_SCOMFIR.MCBISTFIRACT1             // 0x07012307
            [2]   MCBISTFIRQ_INTERNAL_FSM_ERROR =       0
            [13]  MCBISTFIRQ_SCOM_RECOVERABLE_REG_PE =  1
            [14]  MCBISTFIRQ_SCOM_FATAL_REG_PE =        0
      MC01.MCBIST.MBA_SCOMFIR.MCBISTFIRMASK             // 0x07012303
            [2]   MCBISTFIRQ_INTERNAL_FSM_ERROR =       0   // checkstop (0,0,0)
            [13]  MCBISTFIRQ_SCOM_RECOVERABLE_REG_PE =  0   // recoverable_error (0,1,0)
            [14]  MCBISTFIRQ_SCOM_FATAL_REG_PE =        0   // checkstop (0,0,0)

      // No magic, so cannot be merged with previous function
      for each functional MCA
        MC01.PORT0.SRQ.MBACALFIR_ACTION0              // 0x07010906
              [0]   MBACALFIR_MASK_MBA_RECOVERABLE_ERROR =    0
              [1]   MBACALFIR_MASK_MBA_NONRECOVERABLE_ERROR = 0
              [4]   MBACALFIR_MASK_RCD_PARITY_ERROR =         0
              [10]  MBACALFIR_MASK_SM_1HOT_ERR =              0
        MC01.PORT0.SRQ.MBACALFIR_ACTION1              // 0x07010907
              [0]   MBACALFIR_MASK_MBA_RECOVERABLE_ERROR =    1
              [1]   MBACALFIR_MASK_MBA_NONRECOVERABLE_ERROR = 0
              [4]   MBACALFIR_MASK_RCD_PARITY_ERROR =         1
              [10]  MBACALFIR_MASK_SM_1HOT_ERR =              0
        MC01.PORT0.SRQ.MBACALFIR_MASK                 // 0x07010903
              [0]   MBACALFIR_MASK_MBA_RECOVERABLE_ERROR =    0   // recoverable_error (0,1,0)
              [1]   MBACALFIR_MASK_MBA_NONRECOVERABLE_ERROR = 0   // checkstop (0,0,0)
              [4]   MBACALFIR_MASK_RCD_PARITY_ERROR =         0   // recoverable_error (0,1,0)
              [10]  MBACALFIR_MASK_SM_1HOT_ERR =              0   // checkstop (0,0,0)
        IOM0.IOM_PHY0_DDRPHY_FIR_ACTION0_REG          // 0x07011006
              [54]  IOM_PHY0_DDRPHY_FIR_REG_DDR_FIR_ERROR_0 = 0
              [55]  IOM_PHY0_DDRPHY_FIR_REG_DDR_FIR_ERROR_1 = 0
              [57]  IOM_PHY0_DDRPHY_FIR_REG_DDR_FIR_ERROR_3 = 0   // no ERROR_2
              [58]  IOM_PHY0_DDRPHY_FIR_REG_DDR_FIR_ERROR_4 = 0
              [59]  IOM_PHY0_DDRPHY_FIR_REG_DDR_FIR_ERROR_5 = 0
              [60]  IOM_PHY0_DDRPHY_FIR_REG_DDR_FIR_ERROR_6 = 0
              [61]  IOM_PHY0_DDRPHY_FIR_REG_DDR_FIR_ERROR_7 = 0
        IOM0.IOM_PHY0_DDRPHY_FIR_ACTION1_REG          // 0x07011007
              [54]  IOM_PHY0_DDRPHY_FIR_REG_DDR_FIR_ERROR_0 = 1
              [55]  IOM_PHY0_DDRPHY_FIR_REG_DDR_FIR_ERROR_1 = 1
              [57]  IOM_PHY0_DDRPHY_FIR_REG_DDR_FIR_ERROR_3 = 1
              [58]  IOM_PHY0_DDRPHY_FIR_REG_DDR_FIR_ERROR_4 = 1
              [59]  IOM_PHY0_DDRPHY_FIR_REG_DDR_FIR_ERROR_5 = 1
              [60]  IOM_PHY0_DDRPHY_FIR_REG_DDR_FIR_ERROR_6 = 1
              [61]  IOM_PHY0_DDRPHY_FIR_REG_DDR_FIR_ERROR_7 = 1
        IOM0.IOM_PHY0_DDRPHY_FIR_MASK_REG             // 0x07011003
              [54]  IOM_PHY0_DDRPHY_FIR_REG_DDR_FIR_ERROR_0 = 0   // recoverable_error (0,1,0)
              [55]  IOM_PHY0_DDRPHY_FIR_REG_DDR_FIR_ERROR_1 = 0   // recoverable_error (0,1,0)
              [57]  IOM_PHY0_DDRPHY_FIR_REG_DDR_FIR_ERROR_3 = 0   // recoverable_error (0,1,0)
              [58]  IOM_PHY0_DDRPHY_FIR_REG_DDR_FIR_ERROR_4 = 0   // recoverable_error (0,1,0)
              [59]  IOM_PHY0_DDRPHY_FIR_REG_DDR_FIR_ERROR_5 = 0   // recoverable_error (0,1,0)
              [60]  IOM_PHY0_DDRPHY_FIR_REG_DDR_FIR_ERROR_6 = 0   // recoverable_error (0,1,0)
              [61]  IOM_PHY0_DDRPHY_FIR_REG_DDR_FIR_ERROR_7 = 0   // recoverable_error (0,1,0)

## mss_draminit: Dram initialize (13.10)

> a) p9_mss_draminit.C (mcbist) -- Nimbus
> b) p9c_mss_draminit.C (mba) -- Cumulus
>    - RCD parity errors are checked before logging other errors - HWP will exit with RC
>    - De-assert dram reset
>    - De-assert bit (Scom) that forces mem clock low - dram clocks start
>    - Raise CKE
>    - Load RCD Control Words
>    - Load MRS - for each dimm pair/ports/rank
>      - ODT Values
>      - MR0-MR6
> c) Check for attentions (even if HWP has error)
>    - FW
>      - Call PRD
>        - If finds and error, commit HWP RC as informational
>        - Else commit HWP RC as normal
>      - Trigger reconfig loop is anything was deconfigured

for each functional MCBIST
  MC01.MCBIST.MBA_SCOMFIR.CCS_MODEQ               // 0x070123A7
        // "It's unclear if we want to run with this true or false. Right now (10/15) this
        // has to be false. Shelton was unclear if this should be on or off in general BRS"
        [0]   CCS_MODEQ_CCS_STOP_ON_ERR =           0
        [1]   CCS_MODEQ_CCS_UE_DISABLE =            0
        [24]  CCS_MODEQ_CFG_CCS_PARITY_AFTER_CMD =  1
        [26]  CCS_MODEQ_COPY_CKE_TO_SPARE_CKE =     1   // Docs: "Does not apply for POWER9. No spare chips to copy to."

  for each functional MCA
    MC01.PORT0.SRQ.MBA_FARB5Q                     // 0x07010918
          // RESET_N should stay low for at least 200us (JEDEC fig 7) for cold boot. Who and when sets it low?
          // "Up, down P down, up N. Somewhat magic numbers - came from Centaur and proven to be the
          // same on Nimbus. Why these are what they are might be lost to time ..."
          [0-1] MBA_FARB5Q_CFG_DDR_DPHY_NCLK =          0x1     // 0b01     // 2nd RMW
          [2-3] MBA_FARB5Q_CFG_DDR_DPHY_PCLK =          0x2     // 0b10     // 2nd RMW
          [4]   MBA_FARB5Q_CFG_DDR_RESETN =             1                   // 3rd RMW (optional (?), only if changes)
          [5]   MBA_FARB5Q_CFG_CCS_ADDR_MUX_SEL =       1                   // 1st RMW (optional, only if changes)
          [6]   MBA_FARB5Q_CFG_CCS_INST_RESET_ENABLE =  0                   // 1st RMW (optional, only if changes)
    delay(500us)  // part of 3rd RMW, but delay is unconditional

  // JEDEC, fig 7,8: delays above and below end at the same point, they are not consecutive.
  // RDIMM spec says that clocks must be stable for 16nCK before RESET_n = 1. This is not explicitly ensured.
  // Below seems unnecessary, we are starting clocks at the same time as deasserting reset (are we?)
  delay(10ns)   // max(10ns, 5tCK), but for all DDR4 Speed Bins 10ns is bigger - JEDEC

  // draminit_cke_helper - this is done only for the first functional MCA because CCS_ADDR_MUX_SEL is set
  for first functional MCA
    // All of this may be used later, maybe creating a function is in order
    // Hostboot stops CCS before sending new programs. I'm not sure it is wise to do, unless there are infinite loops
    // MC01.MCBIST.MBA_SCOMFIR.CCS_CNTLQ          // 0x070123A5
    //        [all] 0
    //        [1]   CCS_CNTLQ_CCS_STOP = 1
    // timeout(50*10ns):
    //    if MC01.MCBIST.MBA_SCOMFIR.CCS_STATQ[0] (CCS_STATQ_CCS_IP) != 1: break          // 0x070123A6
    //    delay(10ns)

    MC01.MCBIST.CCS.CCS_INST_ARR0_00              // 0x07012315
          [all]   0
          // "ACT is high. It's a no-care in the spec but it seems to raise questions when
          // people look at the trace, so lets set it high."
          [20]    CCS_INST_ARR0_00_CCS_DDR_ACTN =     1
          // "CKE is high Note: P8 set all 4 of these high - not sure if that's correct. BRS"
          [24-27] CCS_INST_ARR0_00_CCS_DDR_CKE =      0xf
          [32-33] CCS_INST_ARR0_00_CCS_DDR_CSN_0_1 =  3
          [36-37] CCS_INST_ARR0_00_CCS_DDR_CSN_2_3 =  3
    MC01.MCBIST.CCS.CCS_INST_ARR1_00              // 0x07012335
          [all]   0
          // According to comments, 400 comes from JEDEC, but I have not seen this value anywhere.
          // What I have seen is tXPR = max(5nCK, tRFC(min) + 10ns). We can discard 5nCK, in any sane configuration
          // it is always smaller than the rest (this is probably defined to cover DLL off mode). tRFC(min) depends
          // on the memory density, it is 160, 260 or 350ns for 2, 4, 8Gb, respectively (16Gb has default and two
          // optional values, but it isn't supported by platform anyway). Unless we want to check memory density
          // here for each DIMM under MCBIST, we should use worst case of 350+10=360ns. This needs to be converted
          // to memory cycles, which (obviously) depends on the memory frequency. Average clock period tCK(avg)
          // varies from <1.5ns (max period for DDR4-1600) to 0.625ns (min period for DDR4-3200), using these numbers
          // we get from 240 to 576 cycles. Calculating backwards, 400 cycles would meet tXPR criteria for tCK = 0.9ns,
          // which is just below the middle of DDR4-2400 Speed Bin for 8Gb (meaning 2400MT/s will work, but 2666MT/s
          // may not, depending on the safety margin used by vendor). For 4Gb density (tXPR = 270ns) with 400 cycles
          // we get tCK = 0.675ns, which lands in DDR4-3200 bin, 2Gb density easily covers all defined DDR4 bins.
          // On the other hand, we wouldn't want to wait for almost 600 cycles on lower speeds...
          //
          // tl;dr version: for 400 cycles
          // - all 2Gb and 4Gb DIMMs should work
          // - 8Gb DIMMs <= 2400MT/s should work
          // - these are guaranteed by spec, rest depends on margins used by vendors
          //
          // -1 is there because CCS does not wait for IDLES for the last command before clearing IP (in progress) bit,
          // so we must use one separate DES instruction at the end
          [0-15]  CCS_INST_ARR1_00_IDLES =    400 - 1
          [59-63] CCS_INST_ARR1_00_GOTO_CMD = 1

    --------------- begin of CCS finalization and execution ----------------
    // Final DES
    MC01.MCBIST.CCS.CCS_INST_ARR0_01              // 0x07012316
          [all]   0
          // "ACT is high. It's a no-care in the spec but it seems to raise questions when
          // people look at the trace, so lets set it high."
          [20]    CCS_INST_ARR0_00_CCS_DDR_ACTN =     1
          // "CKE is high Note: P8 set all 4 of these high - not sure if that's correct. BRS"
          [24-27] CCS_INST_ARR0_00_CCS_DDR_CKE =      0xf
          [32-33] CCS_INST_ARR0_00_CCS_DDR_CSN_0_1 =  3
          [36-37] CCS_INST_ARR0_00_CCS_DDR_CSN_2_3 =  3
    MC01.MCBIST.CCS.CCS_INST_ARR1_01              // 0x07012336
          [all]   0
          [58]    CCS_INST_ARR1_00_CCS_END = 1
    // Select ports
    MC01.MCBIST.MBA_SCOMFIR.MCB_CNTLQ             // 0x070123DB
          // Broadcast mode is not supported, set only one bit at a time
          [2-5]   MCB_CNTLQ_MCBCNTL_PORT_SEL = bitmap with MCA index  // not always 0x8 (port 0), it may not be functional

    // Lets go
    MC01.MCBIST.MBA_SCOMFIR.CCS_CNTLQ          // 0x070123A5
          [all] 0
          [0]   CCS_CNTLQ_CCS_START = 1
    delay(400 memclocks)  // initial delay of poll method, maybe it should be slightly lower? Code execution takes time
    timeout(50*10ns):
      if MC01.MCBIST.MBA_SCOMFIR.CCS_STATQ[0] (CCS_STATQ_CCS_IP) != 1: break          // 0x070123A6
      delay(10ns)
    if MC01.MCBIST.MBA_SCOMFIR.CCS_STATQ != 0x40..00: report failure  // only [1] set, others 0
    --------------- end of CCS finalization and execution ----------------


    cleanup_from_execute()  - no-op if not LRDIMM_CAPABLE

  // "Per conversation with Shelton and Steve, turn off addr_mux_sel after the CKE CCS but before the RCD/MRS CCSs"
  // TODO: is the last DES being repeated still after this? We need CKE high later so RCD stays on. Is there any way
  // for us to test it? Or is there someone who knows?
  for each functional MCA
    MC01.PORT0.SRQ.MBA_FARB5Q                     // 0x07010918
          [5]   MBA_FARB5Q_CFG_CCS_ADDR_MUX_SEL = 0

  // Load RCD control words
  for each functional MCA
    rcd_load(MCA)
      // Hostboot supposedly is data-driven, however, most of the times it is the code that prepares that data. See e.g.
      // src/import/chips/p9/procedures/hwp/memory/lib/dimm/eff_dimm.C. It is full of (get attr, attr[port][dimm] = const,
      // set attr) sequences. Sometimes the value depends on e.g. memory frequency or timings, usually read from SPD data.
      // Sometimes values are unnecessarily converted multiple times between micro-/nano-/picoseconds and memory cycles.
      // This is also true for Register Control Words.
      //
      // There are two ways of accessing RCWs: in-band on the memory channel as an MRS command ("MR7") or through I2C.
      //
      // From JESD82-31: "For changes to the control word setting, (...) the controller needs to wait tMRD after
      // _the last control word access_, before further access _to the DRAM_ can take place".
      // MRS is passed to rank 0 of the DRAM, but MR7 is reserved so it is ignored by DRAM. tMRD (8nCK) applies here,
      // unless longer delay is needed for RCWs which control the clock timing (see JESD82-31 for list of such). This
      // makes sense from DRAMs point of view, however we are talking to the Registering Clock Driver (RCD), not DRAM.
      // From parts marked in the sentence above one may assume that only one delay at the end is necessary and RCWs
      // can be written back to back; however, in the same document in table 141 tMRD is defined as "Number of clock
      // cycles between two control word accesses, MRS accesses, or any DRAM commands".
      //
      // I2C access to RCWs is required to support byte writes, and writes in blocks of up to double word (32b) size.
      // Bigger blocks are not required. Reads must always be 32b, 32b-aligned blocks, even when read as bytes. RCD
      // ignores the two lowest bits so unaligned accesses would return shifted values. RCWs are tightly packed in I2C
      // space, so it is not possible to write just one 4b RCW without writing its neighbor. This is especially
      // important for F0RC06 - Command Space Control Word, as it it able to reset the state of RCD. For this reason,
      // the mentioned register has NOP command (all 1's). JESD82-31 does not specify timeouts required for such
      // multi-RCWs writes, or any other writes. These are not MRS accesses, so it would be strange to apply those
      // timeouts. Perhaps only the registers that actually change the clock settings require time to stabilize.
      // On the other hand, I2C is relatively slow, so it is possible that the write itself is long enough.
      // RCD I2C address is 0xBx, it should be located on the same bus as SPD (number 3 in Petitboot). It uses a bit
      // unusual bus command encoding, see section 3.3 in JESD82-31 and/or `scripts/rcd_i2c_dump.sh` in this repository
      // for an example of reading and writing register values.
      // TODO: calculate whether we need additional timeouts.
      // TODO2: do we need draminit_cke_helper() when using I2C access, too? Maybe it should be done after RCD is set?
      //
      // From a comment in the code:
      // > Secret sauce : insider knowledge
      // > The JEDEC spec doesn't mention anything about ordering of RCWs
      // > but a supplier informed us that we need to send with CKE low:
      // > 4-bit RCWs first (excluding RC09), followed by 8-bit RCWs.
      // > Then with CKE high (We raise it w/the RCW): 4-bit RC09
      // This may come from an older version of spec, JESD82-31A precises (second paragraph in 2.23) that CKE is
      // "don't care" as long as CKE power down feature is disabled. This is the default setting, it is controlled
      // by a bit in F0RC09, which is why it works when this register is written as the last one. This may also be
      // somehow connected with "BUG?" in MC01.MCBIST.CCS.CCS_INST_ARR0_00 and MC01.MCBIST.CCS.CCS_INST_ARR0_01.
      //
      // > You're probably asking "Why always turn off CKE's? What is this madness?"
      // > Well, due to a vendor sensitivity, we need to have the CKE's off until we run RC09 at the very end
      // > Unfortunately, we need to have the CKE's off on the DIMM we are running second
      // > We also don't want to turn off the CKE's on the DIMM we are running first
      // > Therefore, we want to setup all RCW commands to have CKE's off across both DIMM's
      // > We then manually turn on the CKE's associated with a specific DIMM
      //
      // I2C probably doesn't have to have CKE set to any particular value.
      //
      // Except for F0RC09, EVERY other register is written once, in order. It doesn't make any sense for registers
      // F0RC4x, F0RC5x and F0RC6x. These are used as a windowed access to other Function spaces (F1, F2, ... F15),
      // and the access itself is initiated by a command written to F0RC06. Host is responsible for putting DRAM in
      // the MPR mode before sending read command, and issuing the MPR read operation after that command. Writes are
      // performed by the RCD.
      //
      // Registers in Hostboot are loaded with the help of CCS. Here are just their values, for loading procedure see
      // src/import/chips/p9/procedures/hwp/memory/lib/dimm/ddr4/control_word_ddr4.H or use I2C. Default values are
      // all 0s on reset. Note these registers are little endian, bit 0 is LSB, the same goes for SPD data.
      //
      // Before accessing RCWs Hostboot drives CKE low by sending PDE command (Power Down Entry). Probably not needed
      // for I2C.
      F0RC00  = 0x0   // depends on reference raw card used, sometimes 0x2 (ref. A, B, C and custom?)
                      // Maybe SPD bytes 137 and 138 can tell this?
      F0RC01  = 0x0   // depends on reference raw card used, sometimes 0xC (ref. C?). JESD82-31: "The system must
                      // read the module SPD to determine which clock outputs are used by the module", but which
                      // bytes? We can also download ref cards schematics and see which clock signals are connected.
      F0RC02  =
          [0] = 1 if(!(16Gb density && x4 width))     // disable A17?     // Why not use SPD[5]?
                      // Hostboot waits for tSTAB, however it is not necessary as long as bit 3 is not changed.
      F0RC03  =
          [0-1] SPD[137][4-5]   // Address/Command drive strength
          [2-3] SPD[137][6-7]   // CS drive strength
                      // There is also a workaround for NVDIMM hybrids, not needed for plain RDIMM
      F0RC04  =
          // BUG? Hostboot reverses bitfields order for RC04, 05
          [0-1] SPD[137][2-3]   // ODT drive strength
          [2-3] SPD[137][0-1]   // CKE drive strength
                      // There is also a workaround for NVDIMM hybrids, not needed for plain RDIMM
      F0RC05  =
          [0-1] SPD[138][2-3]   // Clocks drive strength, A side (1,3)
          [2-3] SPD[138][0-1]   // Clocks drive strength, B side (0,2)
                      // There is also a workaround for NVDIMM hybrids, not needed for plain RDIMM
      F0RC06  = 0xf   // This is a command register, either don't touch it or use NOP (F)
      F0RC07  = 0x0   // This is a command register, either don't touch it or use NOP (0)
      F0RC08  =
          [0-1] =
              1 if master ranks == 4 (SPD[12])        // C0 and C1 enabled      // master rank AKA package rank
              3 if not 3DS (check SPD[6] and SPD[10]) // all disabled
              2 if slave ranks <= 2                   // C0 enabled             // slave rank AKA logical rank...
              1 if slave ranks <= 4                   // C0 and C1 enabled      // ...SPD[6] Die Count
              0 otherwise (3DS with 5-8 slave ranks)  // C0, C1 and C2 enabled
          [3] = 1 if(!(16Gb density && x4 width))     // disable A17?     // Why not use SPD[5]?
      F0RC09  =
          [2] =
              // TODO: add test for it. Maybe leave it as 0 for now, this is "just" for power saving.
              0 if this DIMM's ODTs are used for writes or reads that target the other DIMM on the same port
              1 otherwise
          [3] = 1     // Register CKE Power Down. CKE must be high at the moment of writing to this register and stay high.
                      // TODO: For how long? Indefinitely, tMRD, tInDIS, tFixedOutput or anything else?
      F0RC0A  =
          [0-2] =     // There are other valid values not used by Hostboot
              1 if 1866 MT/s
              2 if 2133 MT/s
              3 if 2400 MT/s
              4 if 2666 MT/s
      F0RC0B  = 0xe   // External VrefCA connected to QVrefCA and BVrefCA
      F0RC0C  = 0     // Normal operating mode
      F0RC0D  =
          [0-1] =         // CS mode
              3 if master ranks == 4 (SPD[12])    // encoded QuadCS
              0 otherwise                         // direct DualCS
          [2] = 1         // RDIMM
          [3] = SPD[136]  // Address mirroring for MRS commands
      F0RC0E  = 0xd     // Parity enable, ALERT_n assertion and re-enable
      F0RC0F  = 0       // Normal mode
      F0RC1x  = 0       // Normal mode, VDD/2
      F0RC2x  = 0       // Normal mode, all I2C accesses enabled
      F0RC3x  =
              0x1f if 1866 MT/s
              0x2c if 2133 MT/s
              0x39 if 2400 MT/s
              0x47 if 2666 MT/s
      F0RC4x  = 0       // Should not be touched at all, it is used to access different function spaces
      F0RC5x  = 0       // Should not be touched at all, it is used to access different function spaces
      F0RC6x  = 0       // Should not be touched at all, it is used to access different function spaces
      F0RC7x  = 0       // Value comes from VPD, 0 is default, it doesn't seem to be changed anywhere in the code...
      F0RC8x  = 0       // Default QxODT timing for reads and for writes
      F0RC9x  = 0       // QxODT not asserted during writes, all ranks
      F0RCAx  = 0       // QxODT not asserted during reads, all ranks
      F0RCBx  =
          [0-2] =       // Note that only the first line is different than F0RC08 (C0 vs. C0 & C1)
              6 if master ranks == 4 (SPD[12])        // C0 enabled             // master rank AKA package rank
              7 if not 3DS (check SPD[6] and SPD[10]) // all disabled
              6 if slave ranks <= 2                   // C0 enabled             // slave rank AKA logical rank...
              4 if slave ranks <= 4                   // C0 and C1 enabled      // ...SPD[6] Die Count
              0 otherwise (3DS with 5-8 slave ranks)  // C0, C1 and C2 enabled

      // After all RCWs are set, DRAM gets reset "to ensure it is reset properly". Can we ever avoid it?
      // Comment: "Note: the minimum for a FORC06 soft reset is 32 cycles, but we empirically tested it at 8k cycles"
      // Shouldn't we rather wait (again!) for periods defined in JESD79-4C? (200us low and 500us high)
      F0RC06 = 0x2      // Set QRST_n to active (low)
      delay(8000 memclocks)
      F0RC06 = 0x3      // Set QRST_n to inactive (high)
      delay(8000 memclocks)

      // Dumped values from currently installed DIMM, from Petitboot:
      // 0xc7 0x18 0x42 0x00 0x00 0x00 0x00 0x00    VID[2], DID[2], RID[1], 3x reserved
      // 0x02 0x01 0x00 0x03 0xcb 0xe4 0x40 0x0d    F0RC00-0F (4b each)
      // 0x00 0x00 0x47 0x00 0x00 0x00 0x00 0x00    F0RC1x-8x (8b each)
      // 0x00 0x00 0x07                             F0RC9x-Bx (8b each), then all zeroes (Error Log Registers)

      mss::ccs::workarounds::hold_cke_high()
        // In Hostboot, all of the above RCW instructions are not executed yet at this point. This function iterates
        // over all of them and latches CKE high after it is first set high (which should be RC09) for all instructions
        // that follow. Since I2C access does not depend on CKE, perhaps we may ignore it and leave CKE high at all
        // times. Note that CKE was set high in draminit_cke_helper and should still be in this state, unless unsetting
        // CCS_ADDR_MUX_SEL or CCS completion changes it.
        //
        // My suggestion is to not touch CKE after draminit_cke_helper() and see if it works. If not, try doing DES with
        // CKE high after/instead of delays after toggling QRST_n in F0RC06.

  // Load data buffer control words (BCW)
  bcw_load(i_target) - not LRDIMM -> no data buffers

  // Load MRS
  mrs_load(i_target)
    // Programming the Mode Registers consists of entering special mode using MRS (Mode Register Set) command and sending
    // MR# values, one at a time, in a specific order (3,6,5,4,2,1,0). Those values are sent using address lines,
    // including bank and bank group lines, which select which MR to write to. One of the implications is that these
    // values cannot be read back. We have to write a whole register even when changing just one bit, this means that we
    // have to remember what was written, or be able to (re)generate valid data. For this platform we have CCS which can
    // be programmed to push all MRs in one sequence of instructions, including all required timeouts. There are two main
    // timeout parameters: tMRD (minimal amount of time between two MRS commands) and tMOD (time between MRS and non-MRS
    // and non-DES command). For all Speed Bins tMRD = 8nCK, tMOD = max(24nCK, 15ns) = 24nCK. Exceptions to those are:
    // - gear down mode
    // - settings to command & address lines: C/A parity latency, CS to C/A latency (only tMRC doesn't apply), PDA mode
    // - VrefDQ training
    // - DLL Enable, DLL Reset (only tMOD doesn't apply)
    // - maximum power saving mode (only tMOD doesn't apply)
    //
    // I have not seen any explicit information as to what is the scope of MR#, but according to the Hostboot's source
    // code there is one set of Mode Registers per rank. Nevertheless, each rank on a DIMM gets the same data usually.
    // CCS is per MCBIST, so we need at most 4 (ports) * 2 (DIMMs per port) * 2 (master ranks per DIMM, is 4 ranks on
    // RDIMM possible/used?) * 2 (A- and B-side) * (7 (# of MRS) + 1 (final DES)) = 256 instructions. CCS holds space
    // for 32 instructions, so we have to divide it and send a set of instructions per DIMM or even smaller chunks.
    //
    // Just the MR# values, send each one in this order using procedure described below. Remember about address mirroring!
    // These bits are also in little endian order. All multi-bit fields must be swizzled.
    --------------------------------------------------
    MR3 =
      [all] 0
      [A3]      1 if 2N mode      // Geardown Mode. Is this why Hostboot doubles tMRD and tMOD?
      [A10-A9]  1                 // CRC to WR latency. 1 = 5nCK for 1600 < freq <= 2666.
      [A8-A6]   0                 // Fine Granularity Refresh. Default 0, depends on MR4[A3]. Attr in MRW, whatever that is.
                                  // On-the-fly FGR is not supported on RDIMM.
      [A5]      0                 // Temp readout. It is 0, won't it impact `sensors`?
    MR6 =
      [all] 0
      [A5-A0]   ATTR_MSS_VPD_MT_VREF_DRAM_WR & 0x3f
      [A6]      ATTR_MSS_VPD_MT_VREF_DRAM_WR & 0x40
      // BUG? Hostboot doesn't take into account minimal values per freq from JESD79-4C
      // Keep in mind that SPD[40] is unsigned MTB and SPD[117] is signed FTB
      [A12-A10] (conv_to_nCK(SPD[40] + SPD[117])) - 4
    MR5 =
      [all] 0
      // ATTR_MSS_VPD_MT_DRAM_RTT_PARK is saved as a value in Ohms. JEDEC uses seemingly strange mapping to describe
      // these values in MR5, however there is some logic to it. All possible values are (240/N) Ohms, where N is between
      // 1 and 7. This N is a value saved into MR5, with reversed bit order, so 60 = 240/4 => 0b001, 80 = 240/3 => 0b110
      // etc, so just don't swizzle this field. A value of 0 (both in VPD as well as in MR5) disables RTT_PARK.
      [A6-A8] 240/ATTR_MSS_VPD_MT_DRAM_RTT_PARK     // integer division rounds properly for 7/34 (watch out for 0)
    MR4 =
      [all] 0
      // code style BUG: src/import/chips/p9/procedures/hwp/memory/lib/dimm/ddr4/mrs04.C#65 uses wrong enum, not harmful
      [A2]  0         // ATTR_MSS_MRW_TEMP_REFRESH_RANGE, default 0
      [A3]  0         // ATTR_MSS_MRW_TEMP_REFRESH_MODE, default 0, impacts MR3[A8-A6]: if this == 0 then MR3[A8-A6] = 0
      [A11] (ATTR_MSS_VPD_MT_PREAMBLE & 0xf0) >> 4
      [A12] (ATTR_MSS_VPD_MT_PREAMBLE & 0x0f)
    MR2 =
      [all] 0
      [A5-A3] =
          if (ATTR_MSS_VPD_MT_PREAMBLE & 0x0f) == 1:    // 2nCK write preamble
            4 if 2400 MT/s      // CWL = 14
            5 if 2666 MT/s      // CWL = 16
          if (ATTR_MSS_VPD_MT_PREAMBLE & 0x0f) == 0:    // 1nCK write preamble
            1 if 1866 MT/s      // CWL = 10
            2 if 2133 MT/s      // CWL = 11
            3 if 2400 MT/s      // CWL = 12
            4 if 2666 MT/s      // CWL = 14
      [A7-A6] =   // Low Power Auto Self Refresh, doesn't use Auto, just Manual mode (normal or extended temp range)
          0 if ATTR_MSS_MRW_REFRESH_RATE_REQUEST == ATTR_MSS_MRW_REFRESH_RATE_REQUEST_SINGLE*
          2 if ATTR_MSS_MRW_REFRESH_RATE_REQUEST == ATTR_MSS_MRW_REFRESH_RATE_REQUEST_DOUBLE*
      // ATTR_MSS_VPD_MT_DRAM_RTT_WR is also saven in Ohms, however this time there is no logic when it comes to
      // VPD<->MR2 mapping. It seems as if JEDEC added third bit later.
      // VPD    MR2
      // 0      0b000     Dynamic ODT Off
      // 80     0b100     RZQ/3
      // 120    0b001     RZQ/2
      // 240    0b010     RZQ/1
      // 1      0b011     Hi-Z
      [A11-A9]  f(ATTR_MSS_VPD_MT_DRAM_RTT_WR)
      [A12]     ATTR_MSS_MRW_DRAM_WRITE_CRC
    MR1 =
      [all] 0
      [A0]      1       // DLL Enable. There is a note about reversed states in JESD79-4C, not sure what this is about...
      [A2-A1] =         // Output Driver Impedance Control
          0 if ATTR_MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS == ENUM_ATTR_MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS_OHM34  // 34 in VPD
          1 if ATTR_MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS == ENUM_ATTR_MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS_OHM48  // 48 in VPD
      // ATTR_MSS_VPD_MT_DRAM_RTT_NOM is saved as a value in Ohms. JEDEC uses seemingly strange mapping to describe
      // these values in MR1, however there is some logic to it. All possible values are (240/N) Ohms, where N is between
      // 1 and 7. This N is a value saved into MR5, with reversed bit order, so 60 = 240/4 => 0b001, 80 = 240/3 => 0b110
      // etc, so just don't swizzle this field. A value of 0 (both in VPD as well as in MR5) disables RTT_PARK.
      // See also ATTR_MSS_VPD_MT_DRAM_RTT_PARK in MR5.
      [A8-A10]  240/ATTR_MSS_VPD_MT_DRAM_RTT_NOM      // integer division rounds properly for 7/34 (watch out for 0)
      [A11] =
          1 if x8     // SPD[12][0-2] == 1
          0 if x4     // SPD[12][0-2] == 0
    // MR0 has two non-contiguous bit fields, numbers in brackets are sorted MSB to LSB.
    MR0 =
      [all] 0
      // Common for all DIMMs in this domain (?), calculated in istep 7.3, encoded! Values are not in order.
      [A12,A6-A4,A2]  CAS Latency
      [A8]            1             // DLL Reset, "Default is to reset DLLs during IPL"
      // JESD79-4C also specifies min of 15ns, we should probably use max of those two values. Field is encoded,
      // not 1:1, and not in order! (values 22 and 24 are swapped)
      [A13,A11-A9]    tWR = conv_to_nCK(SPD[41-42])
    --------------------------------------------------

    for each DIMM
      // Procedure for sending MRS through CCS
      //
      // We need to remember about two things here:
      // - RDIMM has A-side and B-side, some address bits are inverted for B-side; side is selected by DBG1 (*)
      // - odd ranks may or may not have mirrored lines, depending on SPD[136].
      // *) When mirroring is enabled DBG0 is used for odd ranks to select side, instead of DBG1.
      //
      // Because of those two reasons we cannot simply repeat MRS data for all sides and ranks, we have to do some juggling
      // instead. Inverting is easy, we just have to XOR with appropriate mask (special case for A17, it is not inverted if
      // it isn't used). Mirroring will require manual bit manipulations, we cannot use two pairs of shift and mask because
      // A11/A13 and BG0/BG1 are not next to each other in the CCS instruction registers.
      //
      // There are no signals that are mirrored but not inverted, which means that the order of those operations doesn't
      // matter.
      --------------------------------------------------
      // Rank 2n, side A
      MC01.MCBIST.CCS.CCS_INST_ARR0_{00, 01, .., 31}    // 0x07012315 + N
            [all]   0
            [0-13]  CCS_INST_ARR0_00_CCS_DDR_ADDRESS_0_13 =   A0-A13 to be written to MR#
            [17-19] CCS_INST_ARR0_00_CCS_DDR_BANK_0_1, CCS_INST_ARR0_00_CCS_DDR_BANK_GROUP_0 = MR#    // swizzled!
            [20]    CCS_INST_ARR0_00_CCS_DDR_ACTN =           1
            // "CKE is high Note: P8 set all 4 of these high - not sure if that's correct. BRS"
            [24-27] CCS_INST_ARR0_00_CCS_DDR_CKE =            0xf
            // The encoding of CS signals in Hostboot seems like it would fail if DIMM1 has more ranks than DIMM0
            // Below depends on CS mode and which DIMM are we on:
            // In encoded QuadCS (i.e. when we have 4 master ranks) on DIMM0:
            //    - rank 0: CSN_0_1 = 0b01, CID_0_1 = 0b00, CSN_2_3 = 0b11
            //    - rank 1: CSN_0_1 = 0b01, CID_0_1 = 0b11, CSN_2_3 = 0b11
            //    - rank 2: CSN_0_1 = 0b10, CID_0_1 = 0b00, CSN_2_3 = 0b11
            //    - rank 3: CSN_0_1 = 0b10, CID_0_1 = 0b11, CSN_2_3 = 0b11
            // In direct DualCS on DIMM0:
            //    - rank 0: CSN_0_1 = 0b01, CID_0_1 = 0b00, CSN_2_3 = 0b11
            //    - rank 1: CSN_0_1 = 0b10, CID_0_1 = 0b00, CSN_2_3 = 0b11
            //    - rank 2: CSN_0_1 = 0b11, CID_0_1 = 0b00, CSN_2_3 = 0b01
            //    - rank 3: CSN_0_1 = 0b11, CID_0_1 = 0b00, CSN_2_3 = 0b10
            // On DIMM1 in both cases CSN_0_1 and CSN_2_3 are exchanged
            [32-33] CCS_INST_ARR0_00_CCS_DDR_CSN_0_1 =        see above
            [34-35] CCS_INST_ARR0_00_CCS_DDR_CID_0_1 =        see above
            [36-37] CCS_INST_ARR0_00_CCS_DDR_CSN_2_3 =        see above
      MC01.MCBIST.CCS.CCS_INST_ARR1_{00, 01, .., 31}    // 0x07012335 + N
            [all]   0
            // Timeout. This is tMRD (8nCK), except for the last one (MR0): tMOD (max(24nCK, 15ns)).
            // Hostboot uses doubled tMRD and tMOD values "to increase margin per lab request", it also waits for
            // tDLLK after the last write: "Adding Per Glancy's request, to ensure DLL locking time".
            //
            // Also, it is not clear if the delay is needed between A- and B-side:
            // > Not sure if we can get tricky here and only delay after the b-side MR. The question is whether the delay
            // > is needed/assumed by the register or is purely a DRAM mandated delay. We know we can't go wrong having
            // > both delays but if we can ever confirm that we only need one we can fix this. BRS
            //
            // TODO: test if all of this is needed, we may have 4x longer delays than necessary. Definitely tDLLK doesn't
            // have to be separated between sides (or even components higher in topology), however the worst case would
            // have to be used.
            [0-15]  CCS_INST_ARR1_00_IDLES =    see above
            [59-63] CCS_INST_ARR1_00_GOTO_CMD = (index of next command)
      // Rank 2n, side B
      MC01.MCBIST.CCS.CCS_INST_ARR0_{00, 01, .., 31}    // 0x07012315 + N
            [all]   0
            [0-13]  CCS_INST_ARR0_00_CCS_DDR_ADDRESS_0_13 =   (A0-A13 to be written to MR#) XOR (A3-A9,A11,A13)
            [14]    CCS_INST_ARR0_02_CCS_DDR_ADDRESS_17 =     1 if used     // 16Gb density && x4 width, or check SPD[5]
            [15]    CCS_INST_ARR0_02_CCS_DDR_BANK_GROUP_1 =   1     // B side
            [17-19] CCS_INST_ARR0_00_CCS_DDR_BANK_0_1, CCS_INST_ARR0_00_CCS_DDR_BANK_GROUP_0 = ~(MR#)   // swizzled!
            [20]    CCS_INST_ARR0_00_CCS_DDR_ACTN =           1
            [24-27] CCS_INST_ARR0_00_CCS_DDR_CKE =            0xf
            [32-33] CCS_INST_ARR0_00_CCS_DDR_CSN_0_1 =        see above
            [34-35] CCS_INST_ARR0_00_CCS_DDR_CID_0_1 =        see above
            [36-37] CCS_INST_ARR0_00_CCS_DDR_CSN_2_3 =        see above
      MC01.MCBIST.CCS.CCS_INST_ARR1_{00, 01, .., 31}    // 0x07012335 + N
            [all]   0
            [0-15]  CCS_INST_ARR1_00_IDLES =    see above
            [59-63] CCS_INST_ARR1_00_GOTO_CMD = (index of next command)

      // Rank 2n+1, side A, only if rank is present
      MC01.MCBIST.CCS.CCS_INST_ARR0_{00, 01, .., 31}    // 0x07012315 + N
            [all]   0
            // Mirroring swaps the following bit pairs:
            //   A3 <->  A4
            //   A5 <->  A6
            //   A7 <->  A8
            //  A12 <-> A13
            //  BA0 <-> BA1
            //  BG0 <-> BG1
            // After mirroring, BG0 is the bit that chooses side B when set.
            [0-13]  CCS_INST_ARR0_00_CCS_DDR_ADDRESS_0_13 =   A0-A13 to be written to MR#, mirrored
            [15]    CCS_INST_ARR0_02_CCS_DDR_BANK_GROUP_1 =   MR#.BG0
            [17-18] CCS_INST_ARR0_00_CCS_DDR_BANK_0_1 =       MR#.BA_0_1, mirrored    // mirrored + swizzled = nop
            [20]    CCS_INST_ARR0_00_CCS_DDR_ACTN =           1
            [24-27] CCS_INST_ARR0_00_CCS_DDR_CKE =            0xf
            [32-33] CCS_INST_ARR0_00_CCS_DDR_CSN_0_1 =        see above
            [34-35] CCS_INST_ARR0_00_CCS_DDR_CID_0_1 =        see above
            [36-37] CCS_INST_ARR0_00_CCS_DDR_CSN_2_3 =        see above
      MC01.MCBIST.CCS.CCS_INST_ARR1_{00, 01, .., 31}    // 0x07012335 + N
            [all]   0
            [0-15]  CCS_INST_ARR1_00_IDLES =    see above
            [59-63] CCS_INST_ARR1_00_GOTO_CMD = (index of next command)

      // Rank 2n+1, side B, only if rank is present
      MC01.MCBIST.CCS.CCS_INST_ARR0_{00, 01, .., 31}    // 0x07012315 + N
            [all]   0
            [0-13]  CCS_INST_ARR0_00_CCS_DDR_ADDRESS_0_13 =   (A0-A13 to be written to MR#) XOR (A3-A9,A11,A13), mirrored
            [14]    CCS_INST_ARR0_02_CCS_DDR_ADDRESS_17 =     1 if used     // 16Gb density && x4 width, or check SPD[5]
            [15]    CCS_INST_ARR0_02_CCS_DDR_BANK_GROUP_1 =   ~MR#.BG0
            [17-18] CCS_INST_ARR0_00_CCS_DDR_BANK_0_1 =       ~(MR#.BA_0_1), mirrored   // mirrored + swizzled = nop
            [19]    CCS_INST_ARR0_02_CCS_DDR_BANK_GROUP_0 =   1   // B side
            [20]    CCS_INST_ARR0_00_CCS_DDR_ACTN =           1
            [24-27] CCS_INST_ARR0_00_CCS_DDR_CKE =            0xf
            [32-33] CCS_INST_ARR0_00_CCS_DDR_CSN_0_1 =        see above
            [34-35] CCS_INST_ARR0_00_CCS_DDR_CID_0_1 =        see above
            [36-37] CCS_INST_ARR0_00_CCS_DDR_CSN_2_3 =        see above
      MC01.MCBIST.CCS.CCS_INST_ARR1_{00, 01, .., 31}    // 0x07012335 + N
            [all]   0
            [0-15]  CCS_INST_ARR1_00_IDLES =    see above
            [59-63] CCS_INST_ARR1_00_GOTO_CMD = (index of next command)

      ...
      ... repeat for all ranks, all MRS commands
      ...

      --------------- do CCS finalization and execution, see draminit_cke_helper ----------------------

mss_post_draminit
!!!!!!!!!!!!!!!
